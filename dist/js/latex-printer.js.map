{"version":3,"sources":["webpack:///webpack/bootstrap 5eccb4ae27ba2cb71b90","webpack:///./src/utils.js","webpack:///./src/prettier/doc-builders.js","webpack:///./src/prettier/doc-printer.js","webpack:///./src/prettier/options.js","webpack:///./src/latex-ast.js","webpack:///./src/prettyprinter.js","webpack:///./src/formatter-prettier.js","webpack:///./node_modules/process/browser.js","webpack:///./src/prettier/util.js","webpack:///./node_modules/string-width/index.js","webpack:///./node_modules/string-width/node_modules/strip-ansi/index.js","webpack:///./node_modules/string-width/node_modules/ansi-regex/index.js","webpack:///./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js","webpack:///./node_modules/emoji-regex/index.js","webpack:///./node_modules/escape-string-regexp/index.js","webpack:///./node_modules/cjk-regex/lib/index.js","webpack:///./node_modules/unicode-regex/lib/index.js","webpack:///./node_modules/unicode-regex/lib/data.generated.js","webpack:///./node_modules/unicode-regex/lib/utils.js","webpack:///./src/ast-utils.js","webpack:///./src/latexpeg.js","webpack:///./src/formatter-token.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;+CC1BlB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,GAAG,yBAAyB;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,4BAA4B;AAC5B,qBAAqB;AACrB,cAAc;AACd,kBAAkB;AAClB,0BAA0B,2BAA2B;AACrD;AACA,GAAG,0CAA0C;AAC7C;AACA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxJA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB;AACnB,mCAAmC,mCAAmC;AACtE;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB,aAAa,mBAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA,kBAAkB;;;;;;;;AChblB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,qCAAqC,eAAe;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,kBAAkB;;;;;;;;ACtGlB;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,eAAe;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;AC3UA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;AC7DA;;AAEA;AACA;AACA;;AAEA,OAAO,0BAA0B;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,mCAAmC;AACjE;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kCAAkC,4CAA4C;;AAE9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzeA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,aAAa,EAAE;AACpC;;AAEA;AACA,gCAAgC,0BAA0B,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;;AAEzB,wCAAwC,qBAAqB;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,gCAAgC,kBAAkB;AAClD,+BAA+B,kBAAkB;AACjD,uCAAuC,kBAAkB;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG,GAAG;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ,QAAQ;AACpD;;AAEA;AACA;AACA,oCAAoC,QAAQ,WAAW;AACvD;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO,6CAA6C,IAAI,8BAA8B;AAClG;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,WAAW,MAAM,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD,OAAO;AACP;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9zBA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,gBAAgB;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACnCA;AACA;;AAEA;;;;;;;;ACHA;;AAEA;AACA;AACA,4BAA4B,4BAA4B;AACxD,aAAa,IAAI,IAAI,IAAI,IAAI;AAC7B;;AAEA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC7CA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACNA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA,oFAAoF,cAAc,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA,iEAAiE,uCAAuC,EAAE;AAC1G;AACA;;;;;;;;ACPA;AACA;AACA,gCAAgC,UAAU,wvmCAAwvmC,EAAE;;;;;;;;ACFpymC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;;AAEA;AACA;AACA;;AAEA,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4CAA4C;AAClE,sBAAsB,6BAA6B;AACnD;AACA;AACA,SAAS;AACT;AACA,sBAAsB,4CAA4C;AAClE,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9VA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB,EAAE;AACjF,sDAAsD,yBAAyB,EAAE;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB,EAAE;AACjF,sDAAsD,yBAAyB,EAAE;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,qBAAqB;AACpC;AACA;;AAEA;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB;;AAErB,gCAAgC,8BAA8B;AAC9D;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC,6BAA6B,QAAQ,gCAAgC;AACrE,2BAA2B,QAAQ,iBAAiB;AACpD;AACA,4BAA4B,SAAS;AACrC,4BAA4B,kBAAkB;AAC9C;AACA,4BAA4B,QAAQ,+BAA+B;AACnE,6BAA6B,QAAQ,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,oBAAoB;AACxD;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE,6BAA6B,wBAAwB;AACrD,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,gCAAgC,SAAS;AACzC,qCAAqC,gBAAgB;AACrD,gCAAgC,QAAQ,2CAA2C;AACnF,uBAAuB,SAAS;AAChC,8CAA8C,SAAS;AACvD,qBAAqB,SAAS;AAC9B,4CAA4C,SAAS;AACrD,6BAA6B,QAAQ,qCAAqC;AAC1E,uBAAuB,QAAQ;AAC/B,8CAA8C,QAAQ;AACtD,qBAAqB,QAAQ;AAC7B,4CAA4C,QAAQ;AACpD,6BAA6B,QAAQ,uCAAuC;AAC5E,6BAA6B,QAAQ,+BAA+B;AACpE,6BAA6B,QAAQ,8BAA8B;AACnE;AACA,6BAA6B,kBAAkB;AAC/C,6BAA6B,SAAS;AACtC,6BAA6B,QAAQ,yBAAyB;AAC9D;AACA,6BAA6B,SAAS;AACtC,6BAA6B,QAAQ,yBAAyB;AAC9D;AACA;AACA;AACA,gCAAgC,QAAQ,8BAA8B;AACtE;AACA,8CAA8C,gCAAgC;AAC9E,wCAAwC,SAAS;AACjD,2CAA2C,QAAQ,8DAA8D;AACjH;AACA,wCAAwC,wCAAwC,cAAc,WAAW,oBAAoB,cAAc,UAAU;AACrJ,kCAAkC,SAAS;AAC3C,qCAAqC,QAAQ,uCAAuC;AACpF;AACA;AACA,6BAA6B,QAAQ,2CAA2C;AAChF,6BAA6B,QAAQ,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,0CAA0C;AAC1C,mBAAmB;AACnB,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,mDAAmD;AACnD,8BAA8B,kBAAkB;;AAEhD;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,QAAQ;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,gEAAgE,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,4DAA4D,oBAAoB;AAChF;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACnuHA;AACA;AACA;AACA;;AAEA,OAAO,wBAAwB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,gCAAgC;AAClE;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,gCAAgC;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA","file":"dist/js/latex-printer.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5eccb4ae27ba2cb71b90","\"use strict\";\nconst ESCAPE = \"\\\\\";\n\n/* \n * Common utility functions \n */\n\nfunction type(x) {\n    if (x === null) {\n        return \"null\";\n    }\n    if (typeof x !== \"object\") {\n        return typeof x;\n    }\n    if (Array.isArray(x)) {\n        return \"array\";\n    }\n    return \"object\";\n}\n\nfunction callSuper(self, meth, args=[]) {\n    // the same as super[meth](...args),\n    // but can be used out of the `class` syntax\n    return Object.getPrototypeOf(self.constructor).prototype[meth].call(self, ...args)\n}\n\nmodule.exports = {type, ESCAPE, callSuper}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n\nfunction assertDoc(val) {\n  /* istanbul ignore if */\n  if (\n    !(typeof val === \"string\" || (val != null && typeof val.type === \"string\"))\n  ) {\n    throw new Error(\n      \"Value \" + JSON.stringify(val) + \" is not a valid document\"\n    );\n  }\n}\n\nfunction concat(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  }\n\n  // We cannot do this until we change `printJSXElement` to not\n  // access the internals of a document directly.\n  // if(parts.length === 1) {\n  //   // If it's a single document, no need to concat it.\n  //   return parts[0];\n  // }\n  return { type: \"concat\", parts };\n}\n\nfunction indent(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return { type: \"indent\", contents };\n}\n\nfunction align(n, contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return { type: \"align\", contents, n };\n}\n\nfunction group(contents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"group\",\n    contents: contents,\n    break: !!opts.shouldBreak,\n    expandedStates: opts.expandedStates\n  };\n}\n\nfunction conditionalGroup(states, opts) {\n  return group(\n    states[0],\n    Object.assign(opts || {}, { expandedStates: states })\n  );\n}\n\nfunction fill(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  }\n\n  return { type: \"fill\", parts };\n}\n\nfunction ifBreak(breakContents, flatContents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (breakContents) {\n      assertDoc(breakContents);\n    }\n    if (flatContents) {\n      assertDoc(flatContents);\n    }\n  }\n\n  return { type: \"if-break\", breakContents, flatContents };\n}\n\nfunction lineSuffix(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n  return { type: \"line-suffix\", contents };\n}\n\nconst lineSuffixBoundary = { type: \"line-suffix-boundary\" };\nconst breakParent = { type: \"break-parent\" };\nconst line = { type: \"line\" };\nconst softline = { type: \"line\", soft: true };\nconst hardline = concat([{ type: \"line\", hard: true }, breakParent]);\nconst literalline = concat([\n  { type: \"line\", hard: true, literal: true },\n  breakParent\n]);\nconst cursor = { type: \"cursor\", placeholder: Symbol(\"cursor\") };\n\nfunction join(sep, arr) {\n  const res = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    if (i !== 0) {\n      res.push(sep);\n    }\n\n    res.push(arr[i]);\n  }\n\n  return concat(res);\n}\n\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  let aligned = doc;\n  if (size > 0) {\n    // Use indent to add tabs for all the levels of tabs we need\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    // Use align for all the spaces that are needed\n    aligned = align(size % tabWidth, aligned);\n    // size is absolute from 0 and not relative to the current\n    // indentation, so we use -Infinity to reset the indentation to 0\n    aligned = align(-Infinity, aligned);\n  }\n  return aligned;\n}\n\nmodule.exports = {\n  concat,\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  fill,\n  lineSuffix,\n  lineSuffixBoundary,\n  cursor,\n  breakParent,\n  ifBreak,\n  indent,\n  align,\n  addAlignmentToDoc\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/prettier/doc-builders.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n\nconst util = require(\"./util\");\nconst docBuilders = require(\"./doc-builders\");\nconst concat = docBuilders.concat;\nconst fill = docBuilders.fill;\nconst cursor = docBuilders.cursor;\n\nconst MODE_BREAK = 1;\nconst MODE_FLAT = 2;\n\nfunction rootIndent() {\n  return {\n    length: 0,\n    value: \"\"\n  };\n}\n\nfunction makeIndent(ind, options) {\n  return {\n    length: ind.length + options.tabWidth,\n    value: ind.value + (options.useTabs ? \"\\t\" : \" \".repeat(options.tabWidth))\n  };\n}\n\nfunction makeAlign(ind, n, options) {\n  return n === -Infinity\n    ? rootIndent()\n    : typeof n === \"string\"\n      ? {\n          length: ind.length + n.length,\n          value: ind.value + n\n        }\n      : options.useTabs && n > 0\n        ? makeIndent(ind, options)\n        : {\n            length: ind.length + n,\n            value: ind.value + \" \".repeat(n)\n          };\n}\n\nfunction fits(next, restCommands, width, options, mustBeFlat) {\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[restIdx - 1]);\n\n      restIdx--;\n\n      continue;\n    }\n\n    const x = cmds.pop();\n    const ind = x[0];\n    const mode = x[1];\n    const doc = x[2];\n\n    if (typeof doc === \"string\") {\n      width -= util.getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"concat\":\n          for (let i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n\n          break;\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n\n          break;\n        case \"group\":\n          if (mustBeFlat && doc.break) {\n            return false;\n          }\n          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);\n\n          break;\n        case \"fill\":\n          for (let i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n        case \"if-break\":\n          if (mode === MODE_BREAK) {\n            if (doc.breakContents) {\n              cmds.push([ind, mode, doc.breakContents]);\n            }\n          }\n          if (mode === MODE_FLAT) {\n            if (doc.flatContents) {\n              cmds.push([ind, mode, doc.flatContents]);\n            }\n          }\n\n          break;\n        case \"line\":\n          switch (mode) {\n            // fallthrough\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  width -= 1;\n                }\n\n                break;\n              }\n              return true;\n\n            case MODE_BREAK:\n              return true;\n          }\n          break;\n      }\n    }\n  }\n  return false;\n}\n\nfunction printDocToString(doc, options) {\n  const width = options.printWidth;\n  const newLine = options.newLine || \"\\n\";\n  let pos = 0;\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n  const cmds = [[rootIndent(), MODE_BREAK, doc]];\n  const out = [];\n  let shouldRemeasure = false;\n  let lineSuffix = [];\n\n  while (cmds.length !== 0) {\n    const x = cmds.pop();\n    const ind = x[0];\n    const mode = x[1];\n    const doc = x[2];\n\n    if (typeof doc === \"string\") {\n      out.push(doc);\n\n      pos += util.getStringWidth(doc);\n    } else {\n      switch (doc.type) {\n        case \"cursor\":\n          out.push(cursor.placeholder);\n\n          break;\n        case \"concat\":\n          for (let i = doc.parts.length - 1; i >= 0; i--) {\n            cmds.push([ind, mode, doc.parts[i]]);\n          }\n\n          break;\n        case \"indent\":\n          cmds.push([makeIndent(ind, options), mode, doc.contents]);\n\n          break;\n        case \"align\":\n          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n\n          break;\n        case \"group\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!shouldRemeasure) {\n                cmds.push([\n                  ind,\n                  doc.break ? MODE_BREAK : MODE_FLAT,\n                  doc.contents\n                ]);\n\n                break;\n              }\n            // fallthrough\n\n            case MODE_BREAK: {\n              shouldRemeasure = false;\n\n              const next = [ind, MODE_FLAT, doc.contents];\n              const rem = width - pos;\n\n              if (!doc.break && fits(next, cmds, rem, options)) {\n                cmds.push(next);\n              } else {\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n                if (doc.expandedStates) {\n                  const mostExpanded =\n                    doc.expandedStates[doc.expandedStates.length - 1];\n\n                  if (doc.break) {\n                    cmds.push([ind, MODE_BREAK, mostExpanded]);\n\n                    break;\n                  } else {\n                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {\n                      if (i >= doc.expandedStates.length) {\n                        cmds.push([ind, MODE_BREAK, mostExpanded]);\n\n                        break;\n                      } else {\n                        const state = doc.expandedStates[i];\n                        const cmd = [ind, MODE_FLAT, state];\n\n                        if (fits(cmd, cmds, rem, options)) {\n                          cmds.push(cmd);\n\n                          break;\n                        }\n                      }\n                    }\n                  }\n                } else {\n                  cmds.push([ind, MODE_BREAK, doc.contents]);\n                }\n              }\n\n              break;\n            }\n          }\n          break;\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n        case \"fill\": {\n          const rem = width - pos;\n\n          const parts = doc.parts;\n          if (parts.length === 0) {\n            break;\n          }\n\n          const content = parts[0];\n          const contentFlatCmd = [ind, MODE_FLAT, content];\n          const contentBreakCmd = [ind, MODE_BREAK, content];\n          const contentFits = fits(contentFlatCmd, [], rem, options, true);\n\n          if (parts.length === 1) {\n            if (contentFits) {\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(contentBreakCmd);\n            }\n            break;\n          }\n\n          const whitespace = parts[1];\n          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n          if (parts.length === 2) {\n            if (contentFits) {\n              cmds.push(whitespaceFlatCmd);\n              cmds.push(contentFlatCmd);\n            } else {\n              cmds.push(whitespaceBreakCmd);\n              cmds.push(contentBreakCmd);\n            }\n            break;\n          }\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but coping all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n          parts.splice(0, 2);\n          const remainingCmd = [ind, mode, fill(parts)];\n\n          const secondContent = parts[0];\n\n          const firstAndSecondContentFlatCmd = [\n            ind,\n            MODE_FLAT,\n            concat([content, whitespace, secondContent])\n          ];\n          const firstAndSecondContentFits = fits(\n            firstAndSecondContentFlatCmd,\n            [],\n            rem,\n            options,\n            true\n          );\n\n          if (firstAndSecondContentFits) {\n            cmds.push(remainingCmd);\n            cmds.push(whitespaceFlatCmd);\n            cmds.push(contentFlatCmd);\n          } else if (contentFits) {\n            cmds.push(remainingCmd);\n            cmds.push(whitespaceBreakCmd);\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(remainingCmd);\n            cmds.push(whitespaceBreakCmd);\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        case \"if-break\":\n          if (mode === MODE_BREAK) {\n            if (doc.breakContents) {\n              cmds.push([ind, mode, doc.breakContents]);\n            }\n          }\n          if (mode === MODE_FLAT) {\n            if (doc.flatContents) {\n              cmds.push([ind, mode, doc.flatContents]);\n            }\n          }\n\n          break;\n        case \"line-suffix\":\n          lineSuffix.push([ind, mode, doc.contents]);\n          break;\n        case \"line-suffix-boundary\":\n          if (lineSuffix.length > 0) {\n            cmds.push([ind, mode, { type: \"line\", hard: true }]);\n          }\n          break;\n        case \"line\":\n          switch (mode) {\n            case MODE_FLAT:\n              if (!doc.hard) {\n                if (!doc.soft) {\n                  out.push(\" \");\n\n                  pos += 1;\n                }\n\n                break;\n              } else {\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n                shouldRemeasure = true;\n              }\n            // fallthrough\n\n            case MODE_BREAK:\n              if (lineSuffix.length) {\n                cmds.push([ind, mode, doc]);\n                [].push.apply(cmds, lineSuffix.reverse());\n                lineSuffix = [];\n                break;\n              }\n\n              if (doc.literal) {\n                out.push(newLine);\n                pos = 0;\n              } else {\n                if (out.length > 0) {\n                  // Trim whitespace at the end of line\n                  while (\n                    out.length > 0 &&\n                    out[out.length - 1].match(/^[^\\S\\n]*$/)\n                  ) {\n                    out.pop();\n                  }\n\n                  if (\n                    out.length &&\n                    (options.parser !== \"markdown\" ||\n                      // preserve markdown's `break` node (two trailing spaces)\n                      !/\\S {2}$/.test(out[out.length - 1]))\n                  ) {\n                    out[out.length - 1] = out[out.length - 1].replace(\n                      /[^\\S\\n]*$/,\n                      \"\"\n                    );\n                  }\n                }\n\n                out.push(newLine + ind.value);\n                pos = ind.length;\n              }\n              break;\n          }\n          break;\n        default:\n      }\n    }\n  }\n\n  const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n  if (cursorPlaceholderIndex !== -1) {\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(cursorPlaceholderIndex + 1).join(\"\");\n\n    return {\n      formatted: beforeCursor + afterCursor,\n      cursor: beforeCursor.length\n    };\n  }\n\n  return { formatted: out.join(\"\") };\n}\n\nmodule.exports = { printDocToString };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/prettier/doc-printer.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n\n\nconst defaults = {\n  cursorOffset: -1,\n  rangeStart: 0,\n  rangeEnd: Infinity,\n  useTabs: true,\n  tabWidth: 8,\n  printWidth: 80,\n  singleQuote: false,\n  trailingComma: \"none\",\n  bracketSpacing: true,\n  jsxBracketSameLine: false,\n  parser: \"babylon\",\n  insertPragma: false,\n  requirePragma: false,\n  semi: true,\n  proseWrap: \"always\",\n  arrowParens: \"avoid\"\n};\n\nconst exampleConfig = Object.assign({}, defaults, {\n  filepath: \"path/to/Filename\",\n  printWidth: 80,\n  originalText: \"text\"\n});\n\n// Copy options and fill in default values.\nfunction normalize(options) {\n  const normalized = Object.assign({}, options || {});\n  const filepath = normalized.filepath;\n\n  if (\n    filepath &&\n    (!normalized.parser || normalized.parser === defaults.parser)\n  ) {\n    const extension = \"\";\n    const filename = \"\";\n  }\n\n  if (normalized.parser === \"json\") {\n    normalized.trailingComma = \"none\";\n  }\n\n  /* istanbul ignore if */\n  if (typeof normalized.trailingComma === \"boolean\") {\n    // Support a deprecated boolean type for the trailing comma config\n    // for a few versions. This code can be removed later.\n    normalized.trailingComma = \"es5\";\n\n    console.warn(\n      \"Warning: `trailingComma` without any argument is deprecated. \" +\n        'Specify \"none\", \"es5\", or \"all\".'\n    );\n  }\n\n  /* istanbul ignore if */\n  if (typeof normalized.proseWrap === \"boolean\") {\n    normalized.proseWrap = normalized.proseWrap ? \"always\" : \"never\";\n\n    console.warn(\n      \"Warning: `proseWrap` with boolean value is deprecated. \" +\n        'Use \"always\", \"never\", or \"preserve\" instead.'\n    );\n  }\n\n  /* istanbul ignore if */\n  if (normalized.parser === \"postcss\") {\n    normalized.parser = \"css\";\n\n    console.warn(\n      'Warning: `parser` with value \"postcss\" is deprecated. ' +\n        'Use \"css\", \"less\" or \"scss\" instead.'\n    );\n  }\n\n  const parserBackup = normalized.parser;\n  if (typeof normalized.parser === \"function\") {\n    // Delete the function from the object to pass validation.\n    delete normalized.parser;\n  }\n\n  // Restore the option back to a function;\n  normalized.parser = parserBackup;\n\n  // For backward compatibility. Deprecated in 0.0.10\n  /* istanbul ignore if */\n  if (\"useFlowParser\" in normalized) {\n    normalized.parser = normalized.useFlowParser ? \"flow\" : \"babylon\";\n    delete normalized.useFlowParser;\n  }\n\n  Object.keys(defaults).forEach(k => {\n    if (normalized[k] == null) {\n      normalized[k] = defaults[k];\n    }\n  });\n\n  return normalized;\n}\n\nmodule.exports = { normalize, defaults };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/prettier/options.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\n/*\n * class definitions for the javascript latex AST\n * (as opposed to the PEG.js generated one)\n */\n\nconst { ESCAPE, type } = require(\"./utils.js\");\n\n/*\n * Classes for the AST types\n */\n\nvar ASTNodeList = class ASTNodeList extends Array {\n    constructor() {\n        super(...arguments);\n        this.TYPE = \"nodelist\";\n    }\n    toString() {\n        return this.join(\"\");\n    }\n};\n\nvar ASTNode = class ASTNode {\n    constructor(type = this.constructor.name.toLowerCase()) {\n        this.TYPE = type;\n    }\n};\n\nvar ContentOnlyNode = class ContentOnlyNode extends ASTNode {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n};\n\nvar ArgsNode = class ArgsNode extends ASTNode {\n    // a node that has this.ags as a property\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    get argsString() {\n        if (typeof this.args !== \"undefined\") {\n            return \"[\" + this.args + \"]\";\n        }\n        return \"\";\n    }\n};\n\nvar Environment = class Environment extends ArgsNode {\n    constructor(env, args, content) {\n        super(args);\n        this.env = env;\n        this.content = content;\n    }\n    toString() {\n        // usually this.content will be an array, but for a verbatim environment\n        // it will be string\n        if (this.content.TYPE === \"string\") {\n            return this.envStart + this.argsString + this.content + this.envEnd;\n        }\n        return (\n            this.envStart +\n            this.argsString +\n            this.content.join(\"\") +\n            this.envEnd\n        );\n    }\n    get envStart() {\n        return ESCAPE + \"begin{\" + this.env + \"}\";\n    }\n    get envEnd() {\n        return ESCAPE + \"end{\" + this.env + \"}\";\n    }\n};\n\nvar Macro = class Macro extends ArgsNode {\n    constructor(name, args) {\n        super(args);\n        this.content = name;\n    }\n    toString() {\n        return ESCAPE + this.content + this.argsString;\n    }\n};\n\nvar Parbreak = class Parbreak extends ASTNode {\n    toString() {\n        return \"\\n\\n\";\n    }\n};\n\nvar Whitespace = class Whitespace extends ASTNode {\n    toString() {\n        return \" \";\n    }\n};\n\nvar Subscript = class Subscript extends ContentOnlyNode {\n    toString() {\n        return \"_{\" + this.content + \"}\";\n    }\n};\n\nvar Superscript = class Superscript extends ContentOnlyNode {\n    toString() {\n        return \"^{\" + this.content + \"}\";\n    }\n};\n\nvar InlineMath = class InlineMath extends ContentOnlyNode {\n    toString() {\n        return \"$\" + this.content.join(\"\") + \"$\";\n    }\n};\n\nvar DisplayMath = class DisplayMath extends ContentOnlyNode {\n    toString() {\n        return ESCAPE + \"[\" + this.content.join(\"\") + ESCAPE + \"]\";\n    }\n};\n\nvar MathEnv = class MathEnv extends Environment {\n    constructor(env, content) {\n        super(env, null, content);\n    }\n};\n\nvar Group = class Group extends ContentOnlyNode {\n    toString() {\n        return \"{\" + this.content + \"}\";\n    }\n};\n\nvar Verbatim = class Verbatim extends Environment {\n    constructor(content) {\n        super(\"verbatim\", null, content);\n    }\n};\n\nvar Verb = class Verb extends ASTNode {\n    constructor(escapeChar, content) {\n        super();\n        this[\"escape\"] = escapeChar;\n        this.content = content;\n    }\n    toString() {\n        return ESCAPE + \"verb\" + this[\"escape\"] + this.content + this[\"escape\"];\n    }\n};\n\nvar CommentEnv = class CommentEnv extends Environment {\n    constructor(content) {\n        super(\"comment\", null, content);\n    }\n    toString() {\n        // comment env cannot have anything after it on the same line\n        return super.toString() + \"\\n\";\n    }\n};\n\nvar CommentNode = class CommentNode extends ASTNode {\n    constructor(sameline, content) {\n        super(\"comment\");\n        this.sameline = sameline;\n        this.content = content;\n    }\n    toString() {\n        if (this.sameline) {\n            return \"%\" + this.content + \"\\n\";\n        }\n        return \"\\n%\" + this.content + \"\\n\";\n    }\n};\n\nvar StringNode = class StringNode extends ASTNode {\n    constructor(content) {\n        super(\"string\");\n        this.content = content;\n    }\n    toString() {\n        return this.content;\n    }\n    get length() {\n        return this.content.length;\n    }\n};\n\nvar ArgList = class ArgList extends ContentOnlyNode {\n    toString() {\n        return this.content ? this.content.join(\"\") : \"\";\n    }\n};\n\nvar Token = class Token extends ASTNode {\n    constructor(token) {\n        super();\n        this.content = token;\n    }\n    toString() {\n        return \"\" + this.token;\n    }\n};\n\n/*\n * Take a PEG object and convert it into a LaTeX AST\n */\nfunction PEGtoAST(node) {\n    switch (type(node)) {\n        case \"null\":\n            return undefined;\n        case \"string\":\n            return new StringNode(node);\n        case \"array\":\n            return new ASTNodeList(...node.map(PEGtoAST));\n        case \"object\":\n            switch (node.TYPE) {\n                case \"whitespace\":\n                    return new Whitespace();\n                case \"parbreak\":\n                    return new Parbreak();\n                case \"subscript\":\n                    return new Subscript(PEGtoAST(node.content));\n                case \"superscript\":\n                    return new Superscript(PEGtoAST(node.content));\n                case \"inlinemath\":\n                    return new InlineMath(PEGtoAST(node.content));\n                case \"displaymath\":\n                    return new DisplayMath(PEGtoAST(node.content));\n                case \"mathenv\":\n                    return new MathEnv(node.env, PEGtoAST(node.content));\n                case \"group\":\n                    return new Group(PEGtoAST(node.content));\n                case \"macro\":\n                    return new Macro(node.content, PEGtoAST(node.args));\n                case \"environment\":\n                    return new Environment(\n                        PEGtoAST(node.env),\n                        PEGtoAST(node.args),\n                        PEGtoAST(node.content)\n                    );\n                case \"verbatim\":\n                    return new Verbatim(PEGtoAST(node.content));\n                case \"verb\":\n                    return new Verb(node[\"escape\"], PEGtoAST(node.content));\n                case \"commentenv\":\n                    return new CommentEnv(PEGtoAST([node.content]));\n                case \"comment\":\n                    return new CommentNode(\n                        node.sameline,\n                        PEGtoAST(node.content)\n                    );\n                case \"arglist\":\n                    return new ArgList(PEGtoAST(node.content));\n            }\n    }\n}\n\n/*\n * Annotate a LaTeX AST by putting in references to the parent, next,\n * and previous nodes.\n */\nfunction ASTannotate(ast, parent, next, previous) {\n    if (!ast) {\n        return;\n    }\n    ast.parent = parent;\n    ast.next = next;\n    ast.previous = previous;\n\n    switch (ast.TYPE) {\n        case \"nodelist\":\n            for (let i = 0; i < ast.length; i++) {\n                previous = i === 0 ? null : ast[i - 1];\n                next = i === ast.length - 1 ? null : ast[i + 1];\n                ASTannotate(ast[i], ast, next, previous);\n            }\n            break;\n        case \"arglist\":\n        case \"subscript\":\n        case \"superscript\":\n        case \"inlinemath\":\n        case \"displaymath\":\n        case \"mathenv\":\n        case \"group\":\n            ASTannotate(ast.content, ast);\n            break;\n        case \"macro\":\n            ASTannotate(ast.args, ast);\n            break;\n        case \"environment\":\n            ASTannotate(ast.content, ast);\n            ASTannotate(ast.args, ast);\n            break;\n        case \"string\":\n        case \"parbreak\":\n        case \"verbatim\":\n        case \"verb\":\n        case \"commentenv\":\n        case \"comment\":\n            break;\n    }\n    return ast;\n}\n\nmodule.exports = {\n    nodeTypes: {\n        ASTNodeList,\n        ASTNode,\n        ContentOnlyNode,\n        ArgsNode,\n        Environment,\n        Macro,\n        Parbreak,\n        Whitespace,\n        Subscript,\n        Superscript,\n        InlineMath,\n        DisplayMath,\n        MathEnv,\n        Group,\n        Verbatim,\n        Verb,\n        CommentEnv,\n        CommentNode,\n        StringNode,\n        ArgList\n    },\n    PEGtoAST,\n    ASTannotate\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/latex-ast.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n\n/*\n * utils for pretty-printing latex\n */\n\nconst latexAst = require(\"./latex-ast.js\");\nconst formatterPrettier = require(\"./formatter-prettier.js\");\nconst formatterToken = require(\"./formatter-token.js\");\nconst latexpeg = require(\"./latexpeg.js\");\n\nconst {\n    ASTattachArgs,\n    gobbleArgsAtMacro,\n    cmpStringNode,\n    ASTremoveExcessSpace,\n    trimWhitespace,\n    isSpaceOrPar,\n    isMathEnvironment,\n    strToAST\n} = require(\"./ast-utils.js\")\n\n\n\nfunction parse(str) {\n    var pegAst = latexpeg.parse(str);\n    var ast = latexAst.PEGtoAST(pegAst);\n    latexAst.ASTannotate(ast);\n    return ast;\n}\n\nfunction tokenPrint(str) {\n    var parsed = str;\n    if (typeof str === 'string') {\n        parsed = parse(str);\n    }\n    ASTremoveExcessSpace(parsed);\n    return formatterToken.printTokenStream(parsed.toTokens());\n}\n\n\nfunction prettierPrint(str, opts) {\n    opts = formatterPrettier.prettierNormalizeOptions(opts);\n    var parsed = str;\n    if (typeof str === 'string') {\n        parsed = parse(str);\n    }\n    ASTremoveExcessSpace(parsed);\n    ASTattachArgs(parsed)\n    return formatterPrettier.prettierPrintDocToString(parsed.toPrettierDoc(), opts).formatted;\n}\n\nmodule.exports = formatterPrettier\nmodule.exports.parse = parse\nmodule.exports.prettierPrint = prettierPrint\nmodule.exports.print = tokenPrint\nmodule.exports.tokenPrint = tokenPrint\n\n\nif (typeof window !== 'undefined') {\n    window.exports = module.exports\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/prettyprinter.js\n// module id = 5\n// module chunks = 0","\"use strict\";\n\n/*\n * add prettier-based formatting to the AST\n */\n\nconst { type, ESCAPE, callSuper } = require(\"./utils.js\");\nconst PRETTIER = require(\"./prettier/doc-builders.js\");\nconst prettierPrintDocToString = require(\"./prettier/doc-printer.js\")\n    .printDocToString;\nconst prettierNormalizeOptions = require(\"./prettier/options.js\").normalize;\n\nconst latexAst = __webpack_require__(4);\nconst {\n    ASTNodeList,\n    ASTNode,\n    ContentOnlyNode,\n    ArgsNode,\n    Environment,\n    Macro,\n    Parbreak,\n    Whitespace,\n    Subscript,\n    Superscript,\n    InlineMath,\n    DisplayMath,\n    MathEnv,\n    Group,\n    Verbatim,\n    Verb,\n    CommentEnv,\n    CommentNode,\n    StringNode,\n    ArgList\n} = latexAst.nodeTypes;\n\nconst {\n    ASTattachArgs,\n    gobbleArgsAtMacro,\n    cmpStringNode,\n    ASTremoveExcessSpace,\n    trimWhitespace,\n    isSpaceOrPar,\n    isMathEnvironment,\n    strToAST,\n    splitTabular\n} = require(\"./ast-utils.js\");\n\n/*\n * Add toPrettierDoc method to each class\n */\n\nASTNodeList.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([\n        PRETTIER.fill([].concat.apply([], this.map(x => x.toPrettierDoc())))\n    ]);\n};\n\nArgsNode.prototype.toPrettierDoc = function() {\n    if (this.args) {\n        return PRETTIER.concat([\n            PRETTIER.group(\n                PRETTIER.concat([\n                    \"[\",\n                    //PRETTIER.indent(\n                    this.args.toPrettierDoc(),\n                    //)\n                    \"]\",\n                    PRETTIER.softline\n                ])\n            )\n        ]);\n    }\n    return PRETTIER.concat([\"\"]);\n};\n\nEnvironment.prototype.toPrettierDoc = function() {\n    switch (\"\" + this.env) {\n        case \"parts\":\n        case \"itemize\":\n        case \"description\":\n        case \"enumerate\":\n            var items = _processEnumerateEnvironment.call(this);\n            //console.log(items, \"\"+this)\n            items = items.map(_enumerateItemToPrettier);\n            items = arrayJoin(\n                items,\n                PRETTIER.concat([PRETTIER.hardline, PRETTIER.hardline])\n            );\n\n            return PRETTIER.concat([\n                PRETTIER.hardline,\n                this.envStart,\n                callSuper(this, \"toPrettierDoc\"),\n                PRETTIER.indent(PRETTIER.concat([PRETTIER.hardline, ...items])),\n                PRETTIER.hardline,\n                this.envEnd\n            ]);\n            break;\n        case \"align\":\n        case \"align*\":\n        case \"matrix\":\n        case \"bmatrix\":\n        case \"pmatrix\":\n        case \"vmatrix\":\n        case \"Bmatrix\":\n        case \"Vmatrix\":\n        case \"smallmatrix\":\n            function getSpace(len = 1) {\n                return new StringNode(\" \".repeat(len));\n            }\n            var alignFunc = (a, width) => {\n                return a + getSpace(width - (\"\" + a).length);\n            };\n\n            var [rows, widths] = splitTabular(this.content);\n\n            rows = rows.map(row => {\n                return row.map((cell, i) => {\n                    if (cell.TYPE === \"colsep\") {\n                        return \" \" + cell.content + \" \";\n                    } else if (cell.TYPE === \"cell\") {\n                        return alignFunc(cell.content, widths[i])            \n                    }\n                    return cell.content\n                })\n            })\n\n            rows = rows.map((x,i) => {\n                if (i === rows.length - 1) {\n                    // add a hardline to every row but the last one\n                    return PRETTIER.concat(x)\n                }\n                return PRETTIER.concat(x.concat(PRETTIER.hardline))\n            })\n\n            return PRETTIER.concat([\n                PRETTIER.hardline,\n                this.envStart,\n                callSuper(this, \"toPrettierDoc\"),\n                PRETTIER.indent(\n                    PRETTIER.concat([PRETTIER.hardline].concat(rows))\n                ),\n                PRETTIER.hardline,\n                this.envEnd\n            ]);\n            break;\n    }\n\n    return PRETTIER.concat([\n        PRETTIER.hardline,\n        this.envStart,\n        callSuper(this, \"toPrettierDoc\"),\n        PRETTIER.indent(\n            PRETTIER.concat([PRETTIER.hardline, this.content.toPrettierDoc()])\n        ),\n        PRETTIER.hardline,\n        this.envEnd\n    ]);\n    return \"\" + this;\n};\n\nMacro.prototype.toPrettierDoc = function() {\n    let start = ESCAPE + this.content;\n    // there are some special macros that\n    // need special formatting\n    switch (this.content) {\n        case \"usepackage\":\n        case \"newcommand\":\n            return PRETTIER.concat([PRETTIER.hardline, start]);\n            break;\n        case \"section\":\n        case \"subsection\":\n        case \"subsubsection\":\n            return PRETTIER.concat([PRETTIER.hardline, start]);\n            break;\n    }\n    return start + this.argsString;\n};\n\nParbreak.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([PRETTIER.hardline, PRETTIER.hardline]);\n};\n\nWhitespace.prototype.toPrettierDoc = function() {\n    return PRETTIER.line;\n};\n\nSubscript.prototype.toPrettierDoc = function() {\n    if (this.content.TYPE === \"group\") {\n        return PRETTIER.concat([\"_\", this.content.toPrettierDoc()]);\n    }\n    return PRETTIER.concat([\n        \"_{\",\n        trimWhitespace(this.content).toPrettierDoc(),\n        \"}\"\n    ]);\n};\n\nSuperscript.prototype.toPrettierDoc = function() {\n    if (this.content.TYPE === \"group\") {\n        return PRETTIER.concat([\"^\", this.content.toPrettierDoc()]);\n    }\n    return PRETTIER.concat([\n        \"^{\",\n        trimWhitespace(this.content).toPrettierDoc(),\n        \"}\"\n    ]);\n};\n\nInlineMath.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([\n        \"$\",\n        trimWhitespace(this.content).toPrettierDoc(),\n        \"$\"\n    ]);\n};\n\nDisplayMath.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([\n        PRETTIER.hardline,\n        ESCAPE + \"[\",\n        PRETTIER.indent(\n            PRETTIER.concat([\n                PRETTIER.hardline,\n                PRETTIER.fill([trimWhitespace(this.content).toPrettierDoc()])\n            ])\n        ),\n        PRETTIER.hardline,\n        ESCAPE + \"]\",\n        PRETTIER.hardline\n    ]);\n};\n\nGroup.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([\"{\", this.content.toPrettierDoc(), \"}\"]);\n};\n\nVerbatim.prototype.toPrettierDoc = function() {\n    return PRETTIER.concat([\"\" + this]);\n};\n\nVerb.prototype.toPrettierDoc = Verbatim.prototype.toPrettierDoc;\n\nCommentEnv.prototype.toPrettierDoc = Verbatim.prototype.toPrettierDoc;\n\nCommentNode.prototype.toPrettierDoc = function() {\n    if (this.sameline) {\n        return PRETTIER.concat([\"%\", \"\" + this.content, PRETTIER.hardline]);\n    }\n    return PRETTIER.concat([\n        PRETTIER.hardline,\n        \"%\",\n        \"\" + this.content,\n        PRETTIER.hardline\n    ]);\n};\n\nStringNode.prototype.toPrettierDoc = function() {\n    return this.content;\n};\n\nArgList.prototype.toPrettierDoc = function() {\n    // replace any \",\" in content with \",\"+PRETTIER.line\n    content = [];\n    for (let i of this.content) {\n        let rendered = i.toPrettierDoc();\n        content.push(rendered);\n        if (rendered === \",\") {\n            content.push(PRETTIER.line);\n        }\n    }\n    //console.log(content)\n    //return PRETTIER.indent(PRETTIER.concat(content))\n    return PRETTIER.indent(\n        PRETTIER.concat(\n            [PRETTIER.softline].concat(content)\n            //.concat([PRETTIER.softline])\n        )\n    );\n};\n\nfunction _processEnumerateEnvironment() {\n    // enumerate environments have a list\n    // of `\\item`s followed by contents.\n    // Find all of these so we can print them with\n    // special rules\n    // returns a list of lists that begins with each `\\item`\n\n    var items = [];\n    var itemsText = new ASTNodeList();\n    for (let i of this.content) {\n        if (i.TYPE === \"macro\" && i.content === \"item\") {\n            if (itemsText.length > 0) {\n                items.push(itemsText);\n                itemsText = new ASTNodeList();\n            }\n        }\n        itemsText.push(i);\n    }\n    if (itemsText.length > 0) {\n        items.push(itemsText);\n    }\n\n    return items.map(trimWhitespace);\n}\n\nfunction _enumerateItemToPrettier(i) {\n    if (i.length === 0) {\n        return PRETTIER.concat([])\n    }\n    var head = i[0];\n    var rest = new ASTNodeList(i.slice(1));\n\n    return PRETTIER.concat([\n        head.toPrettierDoc(),\n        PRETTIER.indent(rest.toPrettierDoc())\n    ]);\n}\n\nfunction splitOn(arr, tok) {\n    // splits `arr` based on `tok`.\n    // `tok` can be a string or an ASTNode\n    // or an array of things to split on\n\n    if (type(tok) === \"array\") {\n        tok = tok.map(strToAST);\n    } else {\n        tok = [strToAST(tok)];\n    }\n\n    var ret = new ASTNodeList(),\n        toks = new ASTNodeList();\n    var tmp = new ASTNodeList();\n    for (let i of arr) {\n        for (let t of tok) {\n            if (i.TYPE === t.TYPE && i.content === t.content) {\n                toks.push(i);\n                ret.push(tmp);\n                tmp = new ASTNodeList();\n            } else {\n                tmp.push(i);\n            }\n        }\n    }\n    ret.push(tmp);\n    return [ret, toks];\n}\n\nfunction joinOn(arr, toks) {\n    // like arrayJoin, but this is the inverse\n    // to splitOn; i.e., it takes an array\n    // of inputs.\n    if (type(toks) != \"array\") {\n        return arrayJoin(arr, toks);\n    }\n\n    var ret = new ASTNodeList();\n    for (let i of arr) {\n        ret.push(i);\n        let tok = toks.shift();\n        if (typeof tok !== \"undefined\") {\n            ret.push(tok);\n        }\n    }\n    return ret;\n}\n\nfunction arrayJoin(arr, tok) {\n    // return a new array where `tok` is inserted\n    // between each array entry\n    var ret = new ASTNodeList();\n    for (let i of arr) {\n        ret.push(i);\n        ret.push(tok);\n    }\n    ret.pop();\n    return ret;\n}\n\nfunction transpose(arr) {\n    // get the transpose of an array of arrays\n\n    var copy = arr.map(x => {\n        return [...x];\n    });\n    var transpose = [];\n    for (let i = 0; i < (arr[0] || []).length; i++) {\n        let tmp = [];\n        for (let r of copy) {\n            let elm = r.shift();\n            if (typeof elm !== \"undefined\") {\n                tmp.push(elm);\n            }\n        }\n        transpose.push(tmp);\n    }\n\n    return transpose;\n}\n\nfunction padTable(\n    rows,\n    colWidths,\n    rowSeps,\n    colSeps,\n    align = \"left\",\n    padColSep = true\n) {\n    // take in a table and insert padding to align all elements\n\n    function getSpace(len = 1) {\n        return new StringNode(\" \".repeat(len));\n    }\n    // set the proper alignment function\n    var alignFunc = (a, width) => {\n        return new ASTNodeList(a, getSpace(width - (\"\" + a).length));\n    };\n    if (align === \"right\") {\n        alignFunc = (a, width) => {\n            return new ASTNodeList(getSpace(width - (\"\" + a).length), a);\n        };\n    } else if (align === \"center\" || align === \"middle\") {\n        alignFunc = (a, width) => {\n            var padd = width - (\"\" + a).length;\n            var left = Math.floor(padd / 2);\n            var right = padd - left;\n            return new ASTNodeList(getSpace(left), a, getSpace(right));\n        };\n    }\n\n    // align the columns\n\n    rows = rows.map(y => {\n        return y.map((x, i) => {\n            return alignFunc(x, colWidths[i]);\n        });\n    });\n\n    if (padColSep) {\n        colSeps = colSeps.map(x => {\n            return x.map(y => {\n                return new ASTNodeList(getSpace(1), y, getSpace(1));\n            });\n        });\n    }\n\n    rows = rows.map((row, i) => {\n        if (row.length === 0) {\n            return new ASTNodeList();\n        }\n        var seps = [...colSeps[i]];\n        var ret = new ASTNodeList(row.shift());\n        while (row.length > 0) {\n            ret.push(seps.shift());\n            ret.push(row.shift());\n        }\n        return ret;\n    });\n\n    //// add some newlines after the row separators\n    //rowSeps = rowSeps.map(x => {return new ASTNodeList(x, new Whitespace())})\n\n    // add the rowSeps to the end of each row\n    rows.map((x, i) => {\n        if (typeof rowSeps[i] !== \"undefined\") {\n            x.push(rowSeps[i]);\n        }\n    });\n    //var mat = joinOn(rows, rowSeps)\n    return rows;\n}\n\nmodule.exports.prettierNormalizeOptions = prettierNormalizeOptions;\nmodule.exports.prettierPrintDocToString = prettierPrintDocToString;\nmodule.exports.prettierPrintDoc = (doc, opts) => {\n    opts = prettierNormalizeOptions(opts);\n    return prettierPrintDocToString(doc, opts);\n};\nmodule.exports.utils = {\n    isMathEnvironment,\n    isSpaceOrPar,\n    cmpStringNode,\n    trimWhitespace,\n    strToAST\n};\n\nif (typeof window !== \"undefined\") {\n    window.exports = module.exports;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatter-prettier.js\n// module id = 6\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 7\n// module chunks = 0","\"use strict\";\n\nconst stringWidth = require(\"string-width\");\nconst emojiRegex = require(\"emoji-regex\")();\nconst escapeStringRegexp = require(\"escape-string-regexp\");\nconst getCjkRegex = require(\"cjk-regex\");\nconst getUnicodeRegex = require(\"unicode-regex\");\n\nconst cjkPattern = getCjkRegex().source;\n\n// http://spec.commonmark.org/0.25/#ascii-punctuation-character\nconst asciiPunctuationCharRange = escapeStringRegexp(\n  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n);\n\n// http://spec.commonmark.org/0.25/#punctuation-character\nconst punctuationCharRange = `${asciiPunctuationCharRange}${getUnicodeRegex([\n  \"Pc\",\n  \"Pd\",\n  \"Pe\",\n  \"Pf\",\n  \"Pi\",\n  \"Po\",\n  \"Ps\"\n]).source.slice(1, -1)}`; // remove bracket expression `[` and `]`\n\nconst punctuationRegex = new RegExp(`[${punctuationCharRange}]`);\n\nfunction isExportDeclaration(node) {\n  if (node) {\n    switch (node.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentExportDeclaration(path) {\n  const parentNode = path.getParentNode();\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nfunction getPenultimate(arr) {\n  if (arr.length > 1) {\n    return arr[arr.length - 2];\n  }\n  return null;\n}\n\nfunction getLast(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return null;\n}\n\nfunction skip(chars) {\n  return (text, index, opts) => {\n    const backwards = opts && opts.backwards;\n\n    // Allow `skip` functions to be threaded together without having\n    // to check for failures (did someone say monads?).\n    if (index === false) {\n      return false;\n    }\n\n    const length = text.length;\n    let cursor = index;\n    while (cursor >= 0 && cursor < length) {\n      const c = text.charAt(cursor);\n      if (chars instanceof RegExp) {\n        if (!chars.test(c)) {\n          return cursor;\n        }\n      } else if (chars.indexOf(c) === -1) {\n        return cursor;\n      }\n\n      backwards ? cursor-- : cursor++;\n    }\n\n    if (cursor === -1 || cursor === length) {\n      // If we reached the beginning or end of the file, return the\n      // out-of-bounds cursor. It's up to the caller to handle this\n      // correctly. We don't want to indicate `false` though if it\n      // actually skipped valid characters.\n      return cursor;\n    }\n    return false;\n  };\n}\n\nconst skipWhitespace = skip(/\\s/);\nconst skipSpaces = skip(\" \\t\");\nconst skipToLineEnd = skip(\",; \\t\");\nconst skipEverythingButNewLine = skip(/[^\\r\\n]/);\n\nfunction skipInlineComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n    for (let i = index + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n  return index;\n}\n\nfunction skipTrailingComment(text, index) {\n  if (index === false) {\n    return false;\n  }\n\n  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n    return skipEverythingButNewLine(text, index);\n  }\n  return index;\n}\n\n// This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\nfunction skipNewline(text, index, opts) {\n  const backwards = opts && opts.backwards;\n  if (index === false) {\n    return false;\n  }\n\n  const atIndex = text.charAt(index);\n  if (backwards) {\n    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n      return index - 2;\n    }\n    if (\n      atIndex === \"\\n\" ||\n      atIndex === \"\\r\" ||\n      atIndex === \"\\u2028\" ||\n      atIndex === \"\\u2029\"\n    ) {\n      return index - 1;\n    }\n  } else {\n    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n      return index + 2;\n    }\n    if (\n      atIndex === \"\\n\" ||\n      atIndex === \"\\r\" ||\n      atIndex === \"\\u2028\" ||\n      atIndex === \"\\u2029\"\n    ) {\n      return index + 1;\n    }\n  }\n\n  return index;\n}\n\nfunction hasNewline(text, index, opts) {\n  opts = opts || {};\n  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  const idx2 = skipNewline(text, idx, opts);\n  return idx !== idx2;\n}\n\nfunction hasNewlineInRange(text, start, end) {\n  for (let i = start; i < end; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Note: this function doesn't ignore leading comments unlike isNextLineEmpty\nfunction isPreviousLineEmpty(text, node) {\n  let idx = locStart(node) - 1;\n  idx = skipSpaces(text, idx, { backwards: true });\n  idx = skipNewline(text, idx, { backwards: true });\n  idx = skipSpaces(text, idx, { backwards: true });\n  const idx2 = skipNewline(text, idx, { backwards: true });\n  return idx !== idx2;\n}\n\nfunction isNextLineEmptyAfterIndex(text, index) {\n  let oldIdx = null;\n  let idx = index;\n  while (idx !== oldIdx) {\n    // We need to skip all the potential trailing inline comments\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n  idx = skipTrailingComment(text, idx);\n  idx = skipNewline(text, idx);\n  return hasNewline(text, idx);\n}\n\nfunction isNextLineEmpty(text, node) {\n  return isNextLineEmptyAfterIndex(text, locEnd(node));\n}\n\nfunction getNextNonSpaceNonCommentCharacterIndex(text, node) {\n  let oldIdx = null;\n  let idx = locEnd(node);\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipSpaces(text, idx);\n    idx = skipInlineComment(text, idx);\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n  }\n  return idx;\n}\n\nfunction getNextNonSpaceNonCommentCharacter(text, node) {\n  return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node));\n}\n\nfunction hasSpaces(text, index, opts) {\n  opts = opts || {};\n  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n  return idx !== index;\n}\n\nfunction locStart(node) {\n  // Handle nodes with decorators. They should start at the first decorator\n  if (\n    node.declaration &&\n    node.declaration.decorators &&\n    node.declaration.decorators.length > 0\n  ) {\n    return locStart(node.declaration.decorators[0]);\n  }\n  if (node.decorators && node.decorators.length > 0) {\n    return locStart(node.decorators[0]);\n  }\n\n  if (node.__location) {\n    return node.__location.startOffset;\n  }\n  if (node.range) {\n    return node.range[0];\n  }\n  if (typeof node.start === \"number\") {\n    return node.start;\n  }\n  if (node.source) {\n    return lineColumnToIndex(node.source.start, node.source.input.css) - 1;\n  }\n  if (node.loc) {\n    return node.loc.start;\n  }\n}\n\nfunction locEnd(node) {\n  const endNode = node.nodes && getLast(node.nodes);\n  if (endNode && node.source && !node.source.end) {\n    node = endNode;\n  }\n\n  let loc;\n  if (node.range) {\n    loc = node.range[1];\n  } else if (typeof node.end === \"number\") {\n    loc = node.end;\n  } else if (node.source) {\n    loc = lineColumnToIndex(node.source.end, node.source.input.css);\n  }\n\n  if (node.__location) {\n    return node.__location.endOffset;\n  }\n  if (node.typeAnnotation) {\n    return Math.max(loc, locEnd(node.typeAnnotation));\n  }\n\n  if (node.loc && !loc) {\n    return node.loc.end;\n  }\n\n  return loc;\n}\n\n// Super inefficient, needs to be cached.\nfunction lineColumnToIndex(lineColumn, text) {\n  let index = 0;\n  for (let i = 0; i < lineColumn.line - 1; ++i) {\n    index = text.indexOf(\"\\n\", index) + 1;\n    if (index === -1) {\n      return -1;\n    }\n  }\n  return index + lineColumn.column;\n}\n\nfunction setLocStart(node, index) {\n  if (node.range) {\n    node.range[0] = index;\n  } else {\n    node.start = index;\n  }\n}\n\nfunction setLocEnd(node, index) {\n  if (node.range) {\n    node.range[1] = index;\n  } else {\n    node.end = index;\n  }\n}\n\nconst PRECEDENCE = {};\n[\n  [\"|>\"],\n  [\"||\", \"??\"],\n  [\"&&\"],\n  [\"|\"],\n  [\"^\"],\n  [\"&\"],\n  [\"==\", \"===\", \"!=\", \"!==\"],\n  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n  [\">>\", \"<<\", \">>>\"],\n  [\"+\", \"-\"],\n  [\"*\", \"/\", \"%\"],\n  [\"**\"]\n].forEach((tier, i) => {\n  tier.forEach(op => {\n    PRECEDENCE[op] = i;\n  });\n});\n\nfunction getPrecedence(op) {\n  return PRECEDENCE[op];\n}\n\nconst equalityOperators = {\n  \"==\": true,\n  \"!=\": true,\n  \"===\": true,\n  \"!==\": true\n};\nconst multiplicativeOperators = {\n  \"*\": true,\n  \"/\": true,\n  \"%\": true\n};\nconst bitshiftOperators = {\n  \">>\": true,\n  \">>>\": true,\n  \"<<\": true\n};\n\nfunction shouldFlatten(parentOp, nodeOp) {\n  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n    return false;\n  }\n\n  // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n  if (parentOp === \"**\") {\n    return false;\n  }\n\n  // x == y == z --> (x == y) == z\n  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n    return false;\n  }\n\n  // x * y % z --> (x * y) % z\n  if (\n    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||\n    (parentOp === \"%\" && multiplicativeOperators[nodeOp])\n  ) {\n    return false;\n  }\n\n  // x << y << z --> (x << y) << z\n  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBitwiseOperator(operator) {\n  return (\n    !!bitshiftOperators[operator] ||\n    operator === \"|\" ||\n    operator === \"^\" ||\n    operator === \"&\"\n  );\n}\n\n// Tests if an expression starts with `{`, or (if forbidFunctionAndClass holds) `function` or `class`.\n// Will be overzealous if there's already necessary grouping parentheses.\nfunction startsWithNoLookaheadToken(node, forbidFunctionAndClass) {\n  node = getLeftMost(node);\n  switch (node.type) {\n    // Hack. Remove after https://github.com/eslint/typescript-eslint-parser/issues/331\n    case \"ObjectPattern\":\n      return !forbidFunctionAndClass;\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n      return forbidFunctionAndClass;\n    case \"ObjectExpression\":\n      return true;\n    case \"MemberExpression\":\n      return startsWithNoLookaheadToken(node.object, forbidFunctionAndClass);\n    case \"TaggedTemplateExpression\":\n      if (node.tag.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n      return startsWithNoLookaheadToken(node.tag, forbidFunctionAndClass);\n    case \"CallExpression\":\n      if (node.callee.type === \"FunctionExpression\") {\n        // IIFEs are always already parenthesized\n        return false;\n      }\n      return startsWithNoLookaheadToken(node.callee, forbidFunctionAndClass);\n    case \"ConditionalExpression\":\n      return startsWithNoLookaheadToken(node.test, forbidFunctionAndClass);\n    case \"UpdateExpression\":\n      return (\n        !node.prefix &&\n        startsWithNoLookaheadToken(node.argument, forbidFunctionAndClass)\n      );\n    case \"BindExpression\":\n      return (\n        node.object &&\n        startsWithNoLookaheadToken(node.object, forbidFunctionAndClass)\n      );\n    case \"SequenceExpression\":\n      return startsWithNoLookaheadToken(\n        node.expressions[0],\n        forbidFunctionAndClass\n      );\n    case \"TSAsExpression\":\n      return startsWithNoLookaheadToken(\n        node.expression,\n        forbidFunctionAndClass\n      );\n    default:\n      return false;\n  }\n}\n\nfunction getLeftMost(node) {\n  if (node.left) {\n    return getLeftMost(node.left);\n  }\n  return node;\n}\n\nfunction hasBlockComments(node) {\n  return node.comments && node.comments.some(isBlockComment);\n}\n\nfunction isBlockComment(comment) {\n  return comment.type === \"Block\" || comment.type === \"CommentBlock\";\n}\n\nfunction hasClosureCompilerTypeCastComment(text, node) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  return (\n    node.comments &&\n    node.comments.some(\n      comment =>\n        comment.leading &&\n        isBlockComment(comment) &&\n        comment.value.match(/^\\*\\s*@type\\s*{[^}]+}\\s*$/) &&\n        getNextNonSpaceNonCommentCharacter(text, comment) === \"(\"\n    )\n  );\n}\n\nfunction getAlignmentSize(value, tabWidth, startIndex) {\n  startIndex = startIndex || 0;\n\n  let size = 0;\n  for (let i = startIndex; i < value.length; ++i) {\n    if (value[i] === \"\\t\") {\n      // Tabs behave in a way that they are aligned to the nearest\n      // multiple of tabWidth:\n      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n\n  return size;\n}\n\nfunction getIndentSize(value, tabWidth) {\n  const lastNewlineIndex = value.lastIndexOf(\"\\n\");\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n\n  return getAlignmentSize(\n    // All the leading whitespaces\n    value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0],\n    tabWidth\n  );\n}\n\nfunction printString(raw, options, isDirectiveLiteral) {\n  // `rawContent` is the string exactly like it appeared in the input source\n  // code, without its enclosing quotes.\n  const rawContent = raw.slice(1, -1);\n\n  const double = { quote: '\"', regex: /\"/g };\n  const single = { quote: \"'\", regex: /'/g };\n\n  const preferred = options.singleQuote ? single : double;\n  const alternate = preferred === single ? double : single;\n\n  let shouldUseAlternateQuote = false;\n  let canChangeDirectiveQuotes = false;\n\n  // If `rawContent` contains at least one of the quote preferred for enclosing\n  // the string, we might want to enclose with the alternate quote instead, to\n  // minimize the number of escaped quotes.\n  // Also check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n  if (\n    rawContent.includes(preferred.quote) ||\n    rawContent.includes(alternate.quote)\n  ) {\n    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n\n    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;\n  } else {\n    canChangeDirectiveQuotes = true;\n  }\n\n  const enclosingQuote =\n    options.parser === \"json\"\n      ? double.quote\n      : shouldUseAlternateQuote ? alternate.quote : preferred.quote;\n\n  // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n  if (isDirectiveLiteral) {\n    if (canChangeDirectiveQuotes) {\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n    return raw;\n  }\n\n  // It might sound unnecessary to use `makeString` even if the string already\n  // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n  // sure that we consistently output the minimum amount of escaped quotes.\n  return makeString(\n    rawContent,\n    enclosingQuote,\n    !(\n      options.parser === \"css\" ||\n      options.parser === \"less\" ||\n      options.parser === \"scss\"\n    )\n  );\n}\n\nfunction makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';\n\n  // Matches _any_ escape and unescaped quotes (both single and double).\n  const regex = /\\\\([\\s\\S])|(['\"])/g;\n\n  // Escape and unescape single and double quotes as needed to be able to\n  // enclose `rawContent` with `enclosingQuote`.\n  const newContent = rawContent.replace(regex, (match, escaped, quote) => {\n    // If we matched an escape, and the escaped character is a quote of the\n    // other type than we intend to enclose the string with, there's no need for\n    // it to be escaped, so return it _without_ the backslash.\n    if (escaped === otherQuote) {\n      return escaped;\n    }\n\n    // If we matched an unescaped quote and it is of the _same_ type as we\n    // intend to enclose the string with, it must be escaped, so return it with\n    // a backslash.\n    if (quote === enclosingQuote) {\n      return \"\\\\\" + quote;\n    }\n\n    if (quote) {\n      return quote;\n    }\n\n    // Unescape any unnecessarily escaped character.\n    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n    return unescapeUnnecessaryEscapes &&\n      /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped)\n      ? escaped\n      : \"\\\\\" + escaped;\n  });\n\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\nfunction printNumber(rawNumber) {\n  return (\n    rawNumber\n      .toLowerCase()\n      // Remove unnecessary plus and zeroes from scientific notation.\n      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")\n      // Remove unnecessary scientific notation (1e0).\n      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")\n      // Make sure numbers always start with a digit.\n      .replace(/^([+-])?\\./, \"$10.\")\n      // Remove extraneous trailing decimal zeroes.\n      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")\n      // Remove trailing dot.\n      .replace(/\\.(?=e|$)/, \"\")\n  );\n}\n\nfunction getMaxContinuousCount(str, target) {\n  const results = str.match(\n    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")\n  );\n\n  if (results === null) {\n    return 0;\n  }\n\n  return results.reduce(\n    (maxCount, result) => Math.max(maxCount, result.length / target.length),\n    0\n  );\n}\n\nfunction mapDoc(doc, callback) {\n  if (doc.parts) {\n    const parts = doc.parts.map(part => mapDoc(part, callback));\n    return callback(Object.assign({}, doc, { parts }));\n  }\n\n  if (doc.contents) {\n    const contents = mapDoc(doc.contents, callback);\n    return callback(Object.assign({}, doc, { contents }));\n  }\n\n  return callback(doc);\n}\n\n/**\n * split text into whitespaces and words\n * @param {string} text\n * @return {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>}\n */\nfunction splitText(text) {\n  const KIND_NON_CJK = \"non-cjk\";\n  const KIND_CJK_CHARACTER = \"cjk-character\";\n  const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";\n\n  const nodes = [];\n\n  text\n    .replace(new RegExp(`(${cjkPattern})\\n(${cjkPattern})`, \"g\"), \"$1$2\")\n    .split(/([ \\t\\n]+)/)\n    .forEach((token, index, tokens) => {\n      // whitespace\n      if (index % 2 === 1) {\n        nodes.push({\n          type: \"whitespace\",\n          value: /\\n/.test(token) ? \"\\n\" : \" \"\n        });\n        return;\n      }\n\n      // word separated by whitespace\n\n      if ((index === 0 || index === tokens.length - 1) && token === \"\") {\n        return;\n      }\n\n      token\n        .split(new RegExp(`(${cjkPattern})`))\n        .forEach((innerToken, innerIndex, innerTokens) => {\n          if (\n            (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&\n            innerToken === \"\"\n          ) {\n            return;\n          }\n\n          // non-CJK word\n          if (innerIndex % 2 === 0) {\n            if (innerToken !== \"\") {\n              appendNode({\n                type: \"word\",\n                value: innerToken,\n                kind: KIND_NON_CJK,\n                hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),\n                hasTrailingPunctuation: punctuationRegex.test(\n                  getLast(innerToken)\n                )\n              });\n            }\n            return;\n          }\n\n          // CJK character\n          appendNode(\n            punctuationRegex.test(innerToken)\n              ? {\n                  type: \"word\",\n                  value: innerToken,\n                  kind: KIND_CJK_PUNCTUATION,\n                  hasLeadingPunctuation: true,\n                  hasTrailingPunctuation: true\n                }\n              : {\n                  type: \"word\",\n                  value: innerToken,\n                  kind: KIND_CJK_CHARACTER,\n                  hasLeadingPunctuation: false,\n                  hasTrailingPunctuation: false\n                }\n          );\n        });\n    });\n\n  return nodes;\n\n  function appendNode(node) {\n    const lastNode = getLast(nodes);\n    if (lastNode && lastNode.type === \"word\") {\n      if (\n        (lastNode.kind === KIND_NON_CJK &&\n          node.kind === KIND_CJK_CHARACTER &&\n          !lastNode.hasTrailingPunctuation) ||\n        (lastNode.kind === KIND_CJK_CHARACTER &&\n          node.kind === KIND_NON_CJK &&\n          !node.hasLeadingPunctuation)\n      ) {\n        nodes.push({ type: \"whitespace\", value: \" \" });\n      } else if (\n        !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&\n        // disallow leading/trailing full-width whitespace\n        ![lastNode.value, node.value].some(value => /\\u3000/.test(value))\n      ) {\n        nodes.push({ type: \"whitespace\", value: \"\" });\n      }\n    }\n    nodes.push(node);\n\n    function isBetween(kind1, kind2) {\n      return (\n        (lastNode.kind === kind1 && node.kind === kind2) ||\n        (lastNode.kind === kind2 && node.kind === kind1)\n      );\n    }\n  }\n}\n\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n\n  // emojis are considered 2-char width for consistency\n  // see https://github.com/sindresorhus/string-width/issues/11\n  // for the reason why not implemented in `string-width`\n  return stringWidth(text.replace(emojiRegex, \"  \"));\n}\n\nmodule.exports = {\n  punctuationRegex,\n  punctuationCharRange,\n  getStringWidth,\n  splitText,\n  mapDoc,\n  getMaxContinuousCount,\n  getPrecedence,\n  shouldFlatten,\n  isBitwiseOperator,\n  isExportDeclaration,\n  getParentExportDeclaration,\n  getPenultimate,\n  getLast,\n  getNextNonSpaceNonCommentCharacterIndex,\n  getNextNonSpaceNonCommentCharacter,\n  skipWhitespace,\n  skipSpaces,\n  skipNewline,\n  isNextLineEmptyAfterIndex,\n  isNextLineEmpty,\n  isPreviousLineEmpty,\n  hasNewline,\n  hasNewlineInRange,\n  hasSpaces,\n  locStart,\n  locEnd,\n  setLocStart,\n  setLocEnd,\n  startsWithNoLookaheadToken,\n  hasBlockComments,\n  isBlockComment,\n  hasClosureCompilerTypeCastComment,\n  getAlignmentSize,\n  getIndentSize,\n  printString,\n  printNumber\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/prettier/util.js\n// module id = 8\n// module chunks = 0","'use strict';\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\n\nmodule.exports = str => {\n\tif (typeof str !== 'string' || str.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstr = stripAnsi(str);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst code = str.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/string-width/index.js\n// module id = 9\n// module chunks = 0","'use strict';\nconst ansiRegex = require('ansi-regex');\n\nmodule.exports = input => typeof input === 'string' ? input.replace(ansiRegex(), '') : input;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/string-width/node_modules/strip-ansi/index.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nmodule.exports = () => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[a-zA-Z\\\\d]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PRZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, 'g');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/string-width/node_modules/ansi-regex/index.js\n// module id = 11\n// module chunks = 0","'use strict';\n/* eslint-disable yoda */\nmodule.exports = x => {\n\tif (Number.isNaN(x)) {\n\t\treturn false;\n\t}\n\n\t// code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tx >= 0x1100 && (\n\t\t\tx <= 0x115f ||  // Hangul Jamo\n\t\t\tx === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tx === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= x && x <= 0x4dbf) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4e00 <= x && x <= 0xa4c6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xa960 <= x && x <= 0xa97c) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xac00 <= x && x <= 0xd7a3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xf900 <= x && x <= 0xfaff) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xfe10 <= x && x <= 0xfe19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xfe30 <= x && x <= 0xfe6b) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xff01 <= x && x <= 0xff60) ||\n\t\t\t(0xffe0 <= x && x <= 0xffe6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1b000 <= x && x <= 0x1b001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1f200 <= x && x <= 0x1f251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= x && x <= 0x3fffd)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js\n// module id = 12\n// module chunks = 0","\"use strict\";\n\nmodule.exports = function () {\n\t// https://mathiasbynens.be/notes/es-unicode-property-escapes#emoji\n\treturn (/\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74)\\uDB40\\uDC7F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]\\uFE0F|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83D\\uDC69\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC68(?:\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F/g\n\t);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/emoji-regex/index.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/escape-string-regexp/index.js\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar punctuation_ranges = [\n    // http://www.unicode.org/charts/PDF/U3000.pdf CJK Symbols and Punctuation\n    [0x3000, 0x303f],\n    // http://www.unicode.org/charts/PDF/UAC00.pdf Hangul Syllables\n    [0xac00, 0xd7af],\n    // http://www.unicode.org/charts/PDF/UFE10.pdf Vertical Forms\n    [0xfe10, 0xfe1f],\n    // http://www.unicode.org/charts/PDF/UFE30.pdf CJK Compatibility Forms\n    // http://www.unicode.org/charts/PDF/UFE50.pdf Small Form Variants\n    [0xfe30, 0xfe6f],\n    // http://www.unicode.org/charts/PDF/UFF00.pdf Halfwidth and Fullwidth Forms\n    [0xff00, 0xff60],\n    [0xffe0, 0xffef],\n];\nvar character_ranges = [\n    // http://www.unicode.org/charts/PDF/U1100.pdf Hangul Jamo\n    [0x1100, 0x11ff],\n    // http://www.unicode.org/charts/PDF/U2E80.pdf CJK Radicals Supplement\n    // http://www.unicode.org/charts/PDF/U2F00.pdf Kangxi Radicals\n    [0x2e80, 0x2fdf],\n    // http://www.unicode.org/charts/PDF/U3040.pdf Hiragana\n    // http://www.unicode.org/charts/PDF/U30A0.pdf Katakana\n    // http://www.unicode.org/charts/PDF/U3100.pdf Bopomofo\n    // http://www.unicode.org/charts/PDF/U3130.pdf Hangul Compatibility Jamo\n    [0x3040, 0x318f],\n    // http://www.unicode.org/charts/PDF/U3200.pdf Enclosed CJK Letters and Months\n    // http://www.unicode.org/charts/PDF/U3300.pdf CJK Compatibility\n    // http://www.unicode.org/charts/PDF/U3400.pdf CJK Unified Ideographs Extension A\n    [0x3200, 0x4dbf],\n    // http://www.unicode.org/charts/PDF/U4E00.pdf CJK Unified Ideographs (Han)\n    [0x4e00, 0x9fff],\n    // http://www.unicode.org/charts/PDF/UA960.pdf Hangul Jamo Extended-A\n    [0xa960, 0xa97f],\n    // http://www.unicode.org/charts/PDF/UF900.pdf CJK Compatibility Ideographs\n    [0xf900, 0xfaff],\n];\nfunction get_regex() {\n    return create_regex(character_ranges.concat(punctuation_ranges));\n}\n// istanbul ignore next\n// tslint:disable-next-line:no-namespace\n(function (get_regex) {\n    function punctuations() {\n        return create_regex(punctuation_ranges);\n    }\n    get_regex.punctuations = punctuations;\n    function characters() {\n        return create_regex(character_ranges);\n    }\n    get_regex.characters = characters;\n})(get_regex || (get_regex = {}));\nfunction create_regex(ranges) {\n    return new RegExp(\"[\" + ranges.map(get_bracket_content).reduce(function (a, b) { return a + b; }) + \"]\", 'g');\n}\nfunction get_bracket_content(range) {\n    return get_escaped_unicode(range[0]) + \"-\" + get_escaped_unicode(range[1]);\n}\nfunction get_escaped_unicode(num) {\n    return \"\\\\u\" + num.toString(16);\n}\nmodule.exports = get_regex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/cjk-regex/lib/index.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar data_generated_1 = require(\"./data.generated\");\nvar utils_1 = require(\"./utils\");\nmodule.exports = function (categories, flag) {\n    var data = data_generated_1.get_data();\n    var ranges = categories.reduce(function (current, category) { return current.concat(data[category]); }, []);\n    return utils_1.build_regex(utils_1.normalize_ranges(ranges), flag);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/unicode-regex/lib/index.js\n// module id = 16\n// module chunks = 0","\"use strict\";\nexports.__esModule = true;\nexports.get_data = function () { return ({ \"Pc\": [[95, 95], [8255, 8256], [8276, 8276], [65075, 65076], [65101, 65103], [65343, 65343]], \"Pe\": [[41, 41], [93, 93], [125, 125], [3899, 3899], [3901, 3901], [5788, 5788], [8262, 8262], [8318, 8318], [8334, 8334], [8969, 8969], [8971, 8971], [9002, 9002], [10089, 10089], [10091, 10091], [10093, 10093], [10095, 10095], [10097, 10097], [10099, 10099], [10101, 10101], [10182, 10182], [10215, 10215], [10217, 10217], [10219, 10219], [10221, 10221], [10223, 10223], [10628, 10628], [10630, 10630], [10632, 10632], [10634, 10634], [10636, 10636], [10638, 10638], [10640, 10640], [10642, 10642], [10644, 10644], [10646, 10646], [10648, 10648], [10713, 10713], [10715, 10715], [10749, 10749], [11811, 11811], [11813, 11813], [11815, 11815], [11817, 11817], [12297, 12297], [12299, 12299], [12301, 12301], [12303, 12303], [12305, 12305], [12309, 12309], [12311, 12311], [12313, 12313], [12315, 12315], [12318, 12319], [64830, 64830], [65048, 65048], [65078, 65078], [65080, 65080], [65082, 65082], [65084, 65084], [65086, 65086], [65088, 65088], [65090, 65090], [65092, 65092], [65096, 65096], [65114, 65114], [65116, 65116], [65118, 65118], [65289, 65289], [65341, 65341], [65373, 65373], [65376, 65376], [65379, 65379]], \"Ps\": [[40, 40], [91, 91], [123, 123], [3898, 3898], [3900, 3900], [5787, 5787], [8218, 8218], [8222, 8222], [8261, 8261], [8317, 8317], [8333, 8333], [8968, 8968], [8970, 8970], [9001, 9001], [10088, 10088], [10090, 10090], [10092, 10092], [10094, 10094], [10096, 10096], [10098, 10098], [10100, 10100], [10181, 10181], [10214, 10214], [10216, 10216], [10218, 10218], [10220, 10220], [10222, 10222], [10627, 10627], [10629, 10629], [10631, 10631], [10633, 10633], [10635, 10635], [10637, 10637], [10639, 10639], [10641, 10641], [10643, 10643], [10645, 10645], [10647, 10647], [10712, 10712], [10714, 10714], [10748, 10748], [11810, 11810], [11812, 11812], [11814, 11814], [11816, 11816], [11842, 11842], [12296, 12296], [12298, 12298], [12300, 12300], [12302, 12302], [12304, 12304], [12308, 12308], [12310, 12310], [12312, 12312], [12314, 12314], [12317, 12317], [64831, 64831], [65047, 65047], [65077, 65077], [65079, 65079], [65081, 65081], [65083, 65083], [65085, 65085], [65087, 65087], [65089, 65089], [65091, 65091], [65095, 65095], [65113, 65113], [65115, 65115], [65117, 65117], [65288, 65288], [65339, 65339], [65371, 65371], [65375, 65375], [65378, 65378]], \"Lm\": [[688, 705], [710, 721], [736, 740], [748, 748], [750, 750], [884, 884], [890, 890], [1369, 1369], [1600, 1600], [1765, 1766], [2036, 2037], [2042, 2042], [2074, 2074], [2084, 2084], [2088, 2088], [2417, 2417], [3654, 3654], [3782, 3782], [4348, 4348], [6103, 6103], [6211, 6211], [6823, 6823], [7288, 7293], [7468, 7530], [7544, 7544], [7579, 7615], [8305, 8305], [8319, 8319], [8336, 8348], [11388, 11389], [11631, 11631], [11823, 11823], [12293, 12293], [12337, 12341], [12347, 12347], [12445, 12446], [12540, 12542], [40981, 40981], [42232, 42237], [42508, 42508], [42623, 42623], [42652, 42653], [42775, 42783], [42864, 42864], [42888, 42888], [43000, 43001], [43471, 43471], [43494, 43494], [43632, 43632], [43741, 43741], [43763, 43764], [43868, 43871], [65392, 65392], [65438, 65439]], \"Mc\": [[2307, 2307], [2363, 2363], [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], [2519, 2519], [2563, 2563], [2622, 2624], [2691, 2691], [2750, 2752], [2761, 2761], [2763, 2764], [2818, 2819], [2878, 2878], [2880, 2880], [2887, 2888], [2891, 2892], [2903, 2903], [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], [3031, 3031], [3073, 3075], [3137, 3140], [3202, 3203], [3262, 3262], [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], [3415, 3415], [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], [3967, 3967], [4139, 4140], [4145, 4145], [4152, 4152], [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], [4239, 4239], [4250, 4252], [6070, 6070], [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], [6741, 6741], [6743, 6743], [6753, 6753], [6755, 6756], [6765, 6770], [6916, 6916], [6965, 6965], [6971, 6971], [6973, 6977], [6979, 6980], [7042, 7042], [7073, 7073], [7078, 7079], [7082, 7082], [7143, 7143], [7146, 7148], [7150, 7150], [7154, 7155], [7204, 7211], [7220, 7221], [7393, 7393], [7410, 7411], [7415, 7415], [12334, 12335], [43043, 43044], [43047, 43047], [43136, 43137], [43188, 43203], [43346, 43347], [43395, 43395], [43444, 43445], [43450, 43451], [43453, 43456], [43567, 43568], [43571, 43572], [43597, 43597], [43643, 43643], [43645, 43645], [43755, 43755], [43758, 43759], [43765, 43765], [44003, 44004], [44006, 44007], [44009, 44010], [44012, 44012]], \"Zp\": [[8233, 8233]], \"Sc\": [[36, 36], [162, 165], [1423, 1423], [1547, 1547], [2546, 2547], [2555, 2555], [2801, 2801], [3065, 3065], [3647, 3647], [6107, 6107], [8352, 8383], [43064, 43064], [65020, 65020], [65129, 65129], [65284, 65284], [65504, 65505], [65509, 65510]], \"Me\": [[1160, 1161], [6846, 6846], [8413, 8416], [8418, 8420], [42608, 42610]], \"Sk\": [[94, 94], [96, 96], [168, 168], [175, 175], [180, 180], [184, 184], [706, 709], [722, 735], [741, 747], [749, 749], [751, 767], [885, 885], [900, 901], [8125, 8125], [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [12443, 12444], [42752, 42774], [42784, 42785], [42889, 42890], [43867, 43867], [64434, 64449], [65342, 65342], [65344, 65344], [65507, 65507]], \"Cs\": [[55296, 55296], [56191, 56192], [56319, 56320], [57343, 57343]], \"Nl\": [[5870, 5872], [8544, 8578], [8581, 8584], [12295, 12295], [12321, 12329], [12344, 12346], [42726, 42735]], \"So\": [[166, 166], [169, 169], [174, 174], [176, 176], [1154, 1154], [1421, 1422], [1550, 1551], [1758, 1758], [1769, 1769], [1789, 1790], [2038, 2038], [2554, 2554], [2928, 2928], [3059, 3064], [3066, 3066], [3199, 3199], [3407, 3407], [3449, 3449], [3841, 3843], [3859, 3859], [3861, 3863], [3866, 3871], [3892, 3892], [3894, 3894], [3896, 3896], [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], [6464, 6464], [6622, 6655], [7009, 7018], [7028, 7036], [8448, 8449], [8451, 8454], [8456, 8457], [8468, 8468], [8470, 8471], [8478, 8483], [8485, 8485], [8487, 8487], [8489, 8489], [8494, 8494], [8506, 8507], [8522, 8522], [8524, 8525], [8527, 8527], [8586, 8587], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], [8615, 8621], [8623, 8653], [8656, 8657], [8659, 8659], [8661, 8691], [8960, 8967], [8972, 8991], [8994, 9000], [9003, 9083], [9085, 9114], [9140, 9179], [9186, 9254], [9280, 9290], [9372, 9449], [9472, 9654], [9656, 9664], [9666, 9719], [9728, 9838], [9840, 10087], [10132, 10175], [10240, 10495], [11008, 11055], [11077, 11078], [11085, 11123], [11126, 11157], [11160, 11193], [11197, 11208], [11210, 11218], [11244, 11247], [11493, 11498], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12292, 12292], [12306, 12307], [12320, 12320], [12342, 12343], [12350, 12351], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], [12880, 12880], [12896, 12927], [12938, 12976], [12992, 13054], [13056, 13311], [19904, 19967], [42128, 42182], [43048, 43051], [43062, 43063], [43065, 43065], [43639, 43641], [65021, 65021], [65508, 65508], [65512, 65512], [65517, 65518], [65532, 65533]], \"Lt\": [[453, 453], [456, 456], [459, 459], [498, 498], [8072, 8079], [8088, 8095], [8104, 8111], [8124, 8124], [8140, 8140], [8188, 8188]], \"Zl\": [[8232, 8232]], \"Lo\": [[170, 170], [186, 186], [443, 443], [448, 451], [660, 660], [1488, 1514], [1520, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], [1749, 1749], [1774, 1775], [1786, 1788], [1791, 1791], [1808, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2208, 2228], [2230, 2237], [2308, 2361], [2365, 2365], [2384, 2384], [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], [2482, 2482], [2486, 2489], [2493, 2493], [2510, 2510], [2524, 2525], [2527, 2529], [2544, 2545], [2556, 2556], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], [2654, 2654], [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2749], [2768, 2768], [2784, 2785], [2809, 2809], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2877], [2908, 2909], [2911, 2913], [2929, 2929], [2947, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], [2972, 2972], [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3024, 3024], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3133, 3133], [3160, 3162], [3168, 3169], [3200, 3200], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3261], [3294, 3294], [3296, 3297], [3313, 3314], [3333, 3340], [3342, 3344], [3346, 3386], [3389, 3389], [3406, 3406], [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], [3517, 3517], [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], [3716, 3716], [3719, 3720], [3722, 3722], [3725, 3725], [3732, 3735], [3737, 3743], [3745, 3747], [3749, 3749], [3751, 3751], [3754, 3755], [3757, 3760], [3762, 3763], [3773, 3773], [3776, 3780], [3804, 3807], [3840, 3840], [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], [4159, 4159], [4176, 4181], [4186, 4189], [4193, 4193], [4197, 4198], [4206, 4208], [4213, 4225], [4238, 4238], [4304, 4346], [4349, 4680], [4682, 4685], [4688, 4694], [4696, 4696], [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], [4800, 4800], [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5900], [5902, 5905], [5920, 5937], [5952, 5969], [5984, 5996], [5998, 6000], [6016, 6067], [6108, 6108], [6176, 6210], [6212, 6263], [6272, 6276], [6279, 6312], [6314, 6314], [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6987], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7409], [7413, 7414], [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12294, 12294], [12348, 12348], [12353, 12438], [12447, 12447], [12449, 12538], [12543, 12543], [12549, 12590], [12593, 12686], [12704, 12730], [12784, 12799], [13312, 13312], [19893, 19893], [19968, 19968], [40938, 40938], [40960, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], [42606, 42606], [42656, 42725], [42895, 42895], [42999, 42999], [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], [43259, 43259], [43261, 43261], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], [43642, 43642], [43646, 43695], [43697, 43697], [43701, 43702], [43705, 43709], [43712, 43712], [43714, 43714], [43739, 43740], [43744, 43754], [43762, 43762], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 44032], [55203, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]], \"Mn\": [[768, 879], [1155, 1159], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1552, 1562], [1611, 1631], [1648, 1648], [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2260, 2273], [2275, 2306], [2362, 2362], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2391], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2641, 2641], [2672, 2673], [2677, 2677], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2810, 2815], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2884], [2893, 2893], [2902, 2902], [2914, 2915], [2946, 2946], [3008, 3008], [3021, 3021], [3072, 3072], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3201], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], [3405, 3405], [3426, 3427], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], [4226, 4226], [4229, 4230], [4237, 4237], [4253, 4253], [4957, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6277, 6278], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6683, 6683], [6742, 6742], [6744, 6750], [6752, 6752], [6754, 6754], [6757, 6764], [6771, 6780], [6783, 6783], [6832, 6845], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], [7142, 7142], [7144, 7145], [7149, 7149], [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], [7405, 7405], [7412, 7412], [7416, 7417], [7616, 7673], [7675, 7679], [8400, 8412], [8417, 8417], [8421, 8432], [11503, 11505], [11647, 11647], [11744, 11775], [12330, 12333], [12441, 12442], [42607, 42607], [42612, 42621], [42654, 42655], [42736, 42737], [43010, 43010], [43014, 43014], [43019, 43019], [43045, 43046], [43204, 43205], [43232, 43249], [43302, 43309], [43335, 43345], [43392, 43394], [43443, 43443], [43446, 43449], [43452, 43452], [43493, 43493], [43561, 43566], [43569, 43570], [43573, 43574], [43587, 43587], [43596, 43596], [43644, 43644], [43696, 43696], [43698, 43700], [43703, 43704], [43710, 43711], [43713, 43713], [43756, 43757], [43766, 43766], [44005, 44005], [44008, 44008], [44013, 44013], [64286, 64286], [65024, 65039], [65056, 65071]], \"Po\": [[33, 35], [37, 39], [42, 42], [44, 44], [46, 47], [58, 59], [63, 64], [92, 92], [161, 161], [167, 167], [182, 183], [191, 191], [894, 894], [903, 903], [1370, 1375], [1417, 1417], [1472, 1472], [1475, 1475], [1478, 1478], [1523, 1524], [1545, 1546], [1548, 1549], [1563, 1563], [1566, 1567], [1642, 1645], [1748, 1748], [1792, 1805], [2039, 2041], [2096, 2110], [2142, 2142], [2404, 2405], [2416, 2416], [2557, 2557], [2800, 2800], [3572, 3572], [3663, 3663], [3674, 3675], [3844, 3858], [3860, 3860], [3973, 3973], [4048, 4052], [4057, 4058], [4170, 4175], [4347, 4347], [4960, 4968], [5741, 5742], [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6149], [6151, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], [7379, 7379], [8214, 8215], [8224, 8231], [8240, 8248], [8251, 8254], [8257, 8259], [8263, 8273], [8275, 8275], [8277, 8286], [11513, 11516], [11518, 11519], [11632, 11632], [11776, 11777], [11782, 11784], [11787, 11787], [11790, 11798], [11800, 11801], [11803, 11803], [11806, 11807], [11818, 11822], [11824, 11833], [11836, 11839], [11841, 11841], [11843, 11849], [12289, 12291], [12349, 12349], [12539, 12539], [42238, 42239], [42509, 42511], [42611, 42611], [42622, 42622], [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], [43260, 43260], [43310, 43311], [43359, 43359], [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], [44011, 44011], [65040, 65046], [65049, 65049], [65072, 65072], [65093, 65094], [65097, 65100], [65104, 65106], [65108, 65111], [65119, 65121], [65128, 65128], [65130, 65131], [65281, 65283], [65285, 65287], [65290, 65290], [65292, 65292], [65294, 65295], [65306, 65307], [65311, 65312], [65340, 65340], [65377, 65377], [65380, 65381]], \"Co\": [[57344, 57344], [63743, 63743]], \"Sm\": [[43, 43], [60, 62], [124, 124], [126, 126], [172, 172], [177, 177], [215, 215], [247, 247], [1014, 1014], [1542, 1544], [8260, 8260], [8274, 8274], [8314, 8316], [8330, 8332], [8472, 8472], [8512, 8516], [8523, 8523], [8592, 8596], [8602, 8603], [8608, 8608], [8611, 8611], [8614, 8614], [8622, 8622], [8654, 8655], [8658, 8658], [8660, 8660], [8692, 8959], [8992, 8993], [9084, 9084], [9115, 9139], [9180, 9185], [9655, 9655], [9665, 9665], [9720, 9727], [9839, 9839], [10176, 10180], [10183, 10213], [10224, 10239], [10496, 10626], [10649, 10711], [10716, 10747], [10750, 11007], [11056, 11076], [11079, 11084], [64297, 64297], [65122, 65122], [65124, 65126], [65291, 65291], [65308, 65310], [65372, 65372], [65374, 65374], [65506, 65506], [65513, 65516]], \"Pf\": [[187, 187], [8217, 8217], [8221, 8221], [8250, 8250], [11779, 11779], [11781, 11781], [11786, 11786], [11789, 11789], [11805, 11805], [11809, 11809]], \"Cc\": [[0, 31], [127, 159]], \"Pi\": [[171, 171], [8216, 8216], [8219, 8220], [8223, 8223], [8249, 8249], [11778, 11778], [11780, 11780], [11785, 11785], [11788, 11788], [11804, 11804], [11808, 11808]], \"Lu\": [[65, 90], [192, 214], [216, 222], [256, 256], [258, 258], [260, 260], [262, 262], [264, 264], [266, 266], [268, 268], [270, 270], [272, 272], [274, 274], [276, 276], [278, 278], [280, 280], [282, 282], [284, 284], [286, 286], [288, 288], [290, 290], [292, 292], [294, 294], [296, 296], [298, 298], [300, 300], [302, 302], [304, 304], [306, 306], [308, 308], [310, 310], [313, 313], [315, 315], [317, 317], [319, 319], [321, 321], [323, 323], [325, 325], [327, 327], [330, 330], [332, 332], [334, 334], [336, 336], [338, 338], [340, 340], [342, 342], [344, 344], [346, 346], [348, 348], [350, 350], [352, 352], [354, 354], [356, 356], [358, 358], [360, 360], [362, 362], [364, 364], [366, 366], [368, 368], [370, 370], [372, 372], [374, 374], [376, 377], [379, 379], [381, 381], [385, 386], [388, 388], [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], [418, 418], [420, 420], [422, 423], [425, 425], [428, 428], [430, 431], [433, 435], [437, 437], [439, 440], [444, 444], [452, 452], [455, 455], [458, 458], [461, 461], [463, 463], [465, 465], [467, 467], [469, 469], [471, 471], [473, 473], [475, 475], [478, 478], [480, 480], [482, 482], [484, 484], [486, 486], [488, 488], [490, 490], [492, 492], [494, 494], [497, 497], [500, 500], [502, 504], [506, 506], [508, 508], [510, 510], [512, 512], [514, 514], [516, 516], [518, 518], [520, 520], [522, 522], [524, 524], [526, 526], [528, 528], [530, 530], [532, 532], [534, 534], [536, 536], [538, 538], [540, 540], [542, 542], [544, 544], [546, 546], [548, 548], [550, 550], [552, 552], [554, 554], [556, 556], [558, 558], [560, 560], [562, 562], [570, 571], [573, 574], [577, 577], [579, 582], [584, 584], [586, 586], [588, 588], [590, 590], [880, 880], [882, 882], [886, 886], [895, 895], [902, 902], [904, 906], [908, 908], [910, 911], [913, 929], [931, 939], [975, 975], [978, 980], [984, 984], [986, 986], [988, 988], [990, 990], [992, 992], [994, 994], [996, 996], [998, 998], [1000, 1000], [1002, 1002], [1004, 1004], [1006, 1006], [1012, 1012], [1015, 1015], [1017, 1018], [1021, 1071], [1120, 1120], [1122, 1122], [1124, 1124], [1126, 1126], [1128, 1128], [1130, 1130], [1132, 1132], [1134, 1134], [1136, 1136], [1138, 1138], [1140, 1140], [1142, 1142], [1144, 1144], [1146, 1146], [1148, 1148], [1150, 1150], [1152, 1152], [1162, 1162], [1164, 1164], [1166, 1166], [1168, 1168], [1170, 1170], [1172, 1172], [1174, 1174], [1176, 1176], [1178, 1178], [1180, 1180], [1182, 1182], [1184, 1184], [1186, 1186], [1188, 1188], [1190, 1190], [1192, 1192], [1194, 1194], [1196, 1196], [1198, 1198], [1200, 1200], [1202, 1202], [1204, 1204], [1206, 1206], [1208, 1208], [1210, 1210], [1212, 1212], [1214, 1214], [1216, 1217], [1219, 1219], [1221, 1221], [1223, 1223], [1225, 1225], [1227, 1227], [1229, 1229], [1232, 1232], [1234, 1234], [1236, 1236], [1238, 1238], [1240, 1240], [1242, 1242], [1244, 1244], [1246, 1246], [1248, 1248], [1250, 1250], [1252, 1252], [1254, 1254], [1256, 1256], [1258, 1258], [1260, 1260], [1262, 1262], [1264, 1264], [1266, 1266], [1268, 1268], [1270, 1270], [1272, 1272], [1274, 1274], [1276, 1276], [1278, 1278], [1280, 1280], [1282, 1282], [1284, 1284], [1286, 1286], [1288, 1288], [1290, 1290], [1292, 1292], [1294, 1294], [1296, 1296], [1298, 1298], [1300, 1300], [1302, 1302], [1304, 1304], [1306, 1306], [1308, 1308], [1310, 1310], [1312, 1312], [1314, 1314], [1316, 1316], [1318, 1318], [1320, 1320], [1322, 1322], [1324, 1324], [1326, 1326], [1329, 1366], [4256, 4293], [4295, 4295], [4301, 4301], [5024, 5109], [7680, 7680], [7682, 7682], [7684, 7684], [7686, 7686], [7688, 7688], [7690, 7690], [7692, 7692], [7694, 7694], [7696, 7696], [7698, 7698], [7700, 7700], [7702, 7702], [7704, 7704], [7706, 7706], [7708, 7708], [7710, 7710], [7712, 7712], [7714, 7714], [7716, 7716], [7718, 7718], [7720, 7720], [7722, 7722], [7724, 7724], [7726, 7726], [7728, 7728], [7730, 7730], [7732, 7732], [7734, 7734], [7736, 7736], [7738, 7738], [7740, 7740], [7742, 7742], [7744, 7744], [7746, 7746], [7748, 7748], [7750, 7750], [7752, 7752], [7754, 7754], [7756, 7756], [7758, 7758], [7760, 7760], [7762, 7762], [7764, 7764], [7766, 7766], [7768, 7768], [7770, 7770], [7772, 7772], [7774, 7774], [7776, 7776], [7778, 7778], [7780, 7780], [7782, 7782], [7784, 7784], [7786, 7786], [7788, 7788], [7790, 7790], [7792, 7792], [7794, 7794], [7796, 7796], [7798, 7798], [7800, 7800], [7802, 7802], [7804, 7804], [7806, 7806], [7808, 7808], [7810, 7810], [7812, 7812], [7814, 7814], [7816, 7816], [7818, 7818], [7820, 7820], [7822, 7822], [7824, 7824], [7826, 7826], [7828, 7828], [7838, 7838], [7840, 7840], [7842, 7842], [7844, 7844], [7846, 7846], [7848, 7848], [7850, 7850], [7852, 7852], [7854, 7854], [7856, 7856], [7858, 7858], [7860, 7860], [7862, 7862], [7864, 7864], [7866, 7866], [7868, 7868], [7870, 7870], [7872, 7872], [7874, 7874], [7876, 7876], [7878, 7878], [7880, 7880], [7882, 7882], [7884, 7884], [7886, 7886], [7888, 7888], [7890, 7890], [7892, 7892], [7894, 7894], [7896, 7896], [7898, 7898], [7900, 7900], [7902, 7902], [7904, 7904], [7906, 7906], [7908, 7908], [7910, 7910], [7912, 7912], [7914, 7914], [7916, 7916], [7918, 7918], [7920, 7920], [7922, 7922], [7924, 7924], [7926, 7926], [7928, 7928], [7930, 7930], [7932, 7932], [7934, 7934], [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], [8025, 8025], [8027, 8027], [8029, 8029], [8031, 8031], [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], [8450, 8450], [8455, 8455], [8459, 8461], [8464, 8466], [8469, 8469], [8473, 8477], [8484, 8484], [8486, 8486], [8488, 8488], [8490, 8493], [8496, 8499], [8510, 8511], [8517, 8517], [8579, 8579], [11264, 11310], [11360, 11360], [11362, 11364], [11367, 11367], [11369, 11369], [11371, 11371], [11373, 11376], [11378, 11378], [11381, 11381], [11390, 11392], [11394, 11394], [11396, 11396], [11398, 11398], [11400, 11400], [11402, 11402], [11404, 11404], [11406, 11406], [11408, 11408], [11410, 11410], [11412, 11412], [11414, 11414], [11416, 11416], [11418, 11418], [11420, 11420], [11422, 11422], [11424, 11424], [11426, 11426], [11428, 11428], [11430, 11430], [11432, 11432], [11434, 11434], [11436, 11436], [11438, 11438], [11440, 11440], [11442, 11442], [11444, 11444], [11446, 11446], [11448, 11448], [11450, 11450], [11452, 11452], [11454, 11454], [11456, 11456], [11458, 11458], [11460, 11460], [11462, 11462], [11464, 11464], [11466, 11466], [11468, 11468], [11470, 11470], [11472, 11472], [11474, 11474], [11476, 11476], [11478, 11478], [11480, 11480], [11482, 11482], [11484, 11484], [11486, 11486], [11488, 11488], [11490, 11490], [11499, 11499], [11501, 11501], [11506, 11506], [42560, 42560], [42562, 42562], [42564, 42564], [42566, 42566], [42568, 42568], [42570, 42570], [42572, 42572], [42574, 42574], [42576, 42576], [42578, 42578], [42580, 42580], [42582, 42582], [42584, 42584], [42586, 42586], [42588, 42588], [42590, 42590], [42592, 42592], [42594, 42594], [42596, 42596], [42598, 42598], [42600, 42600], [42602, 42602], [42604, 42604], [42624, 42624], [42626, 42626], [42628, 42628], [42630, 42630], [42632, 42632], [42634, 42634], [42636, 42636], [42638, 42638], [42640, 42640], [42642, 42642], [42644, 42644], [42646, 42646], [42648, 42648], [42650, 42650], [42786, 42786], [42788, 42788], [42790, 42790], [42792, 42792], [42794, 42794], [42796, 42796], [42798, 42798], [42802, 42802], [42804, 42804], [42806, 42806], [42808, 42808], [42810, 42810], [42812, 42812], [42814, 42814], [42816, 42816], [42818, 42818], [42820, 42820], [42822, 42822], [42824, 42824], [42826, 42826], [42828, 42828], [42830, 42830], [42832, 42832], [42834, 42834], [42836, 42836], [42838, 42838], [42840, 42840], [42842, 42842], [42844, 42844], [42846, 42846], [42848, 42848], [42850, 42850], [42852, 42852], [42854, 42854], [42856, 42856], [42858, 42858], [42860, 42860], [42862, 42862], [42873, 42873], [42875, 42875], [42877, 42878], [42880, 42880], [42882, 42882], [42884, 42884], [42886, 42886], [42891, 42891], [42893, 42893], [42896, 42896], [42898, 42898], [42902, 42902], [42904, 42904], [42906, 42906], [42908, 42908], [42910, 42910], [42912, 42912], [42914, 42914], [42916, 42916], [42918, 42918], [42920, 42920], [42922, 42926], [42928, 42932], [42934, 42934], [65313, 65338]], \"Pd\": [[45, 45], [1418, 1418], [1470, 1470], [5120, 5120], [6150, 6150], [8208, 8213], [11799, 11799], [11802, 11802], [11834, 11835], [11840, 11840], [12316, 12316], [12336, 12336], [12448, 12448], [65073, 65074], [65112, 65112], [65123, 65123], [65293, 65293]], \"Cf\": [[173, 173], [1536, 1541], [1564, 1564], [1757, 1757], [1807, 1807], [2274, 2274], [6158, 6158], [8203, 8207], [8234, 8238], [8288, 8292], [8294, 8303], [65279, 65279], [65529, 65531]], \"Nd\": [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305]], \"Ll\": [[97, 122], [181, 181], [223, 246], [248, 255], [257, 257], [259, 259], [261, 261], [263, 263], [265, 265], [267, 267], [269, 269], [271, 271], [273, 273], [275, 275], [277, 277], [279, 279], [281, 281], [283, 283], [285, 285], [287, 287], [289, 289], [291, 291], [293, 293], [295, 295], [297, 297], [299, 299], [301, 301], [303, 303], [305, 305], [307, 307], [309, 309], [311, 312], [314, 314], [316, 316], [318, 318], [320, 320], [322, 322], [324, 324], [326, 326], [328, 329], [331, 331], [333, 333], [335, 335], [337, 337], [339, 339], [341, 341], [343, 343], [345, 345], [347, 347], [349, 349], [351, 351], [353, 353], [355, 355], [357, 357], [359, 359], [361, 361], [363, 363], [365, 365], [367, 367], [369, 369], [371, 371], [373, 373], [375, 375], [378, 378], [380, 380], [382, 384], [387, 387], [389, 389], [392, 392], [396, 397], [402, 402], [405, 405], [409, 411], [414, 414], [417, 417], [419, 419], [421, 421], [424, 424], [426, 427], [429, 429], [432, 432], [436, 436], [438, 438], [441, 442], [445, 447], [454, 454], [457, 457], [460, 460], [462, 462], [464, 464], [466, 466], [468, 468], [470, 470], [472, 472], [474, 474], [476, 477], [479, 479], [481, 481], [483, 483], [485, 485], [487, 487], [489, 489], [491, 491], [493, 493], [495, 496], [499, 499], [501, 501], [505, 505], [507, 507], [509, 509], [511, 511], [513, 513], [515, 515], [517, 517], [519, 519], [521, 521], [523, 523], [525, 525], [527, 527], [529, 529], [531, 531], [533, 533], [535, 535], [537, 537], [539, 539], [541, 541], [543, 543], [545, 545], [547, 547], [549, 549], [551, 551], [553, 553], [555, 555], [557, 557], [559, 559], [561, 561], [563, 569], [572, 572], [575, 576], [578, 578], [583, 583], [585, 585], [587, 587], [589, 589], [591, 659], [661, 687], [881, 881], [883, 883], [887, 887], [891, 893], [912, 912], [940, 974], [976, 977], [981, 983], [985, 985], [987, 987], [989, 989], [991, 991], [993, 993], [995, 995], [997, 997], [999, 999], [1001, 1001], [1003, 1003], [1005, 1005], [1007, 1011], [1013, 1013], [1016, 1016], [1019, 1020], [1072, 1119], [1121, 1121], [1123, 1123], [1125, 1125], [1127, 1127], [1129, 1129], [1131, 1131], [1133, 1133], [1135, 1135], [1137, 1137], [1139, 1139], [1141, 1141], [1143, 1143], [1145, 1145], [1147, 1147], [1149, 1149], [1151, 1151], [1153, 1153], [1163, 1163], [1165, 1165], [1167, 1167], [1169, 1169], [1171, 1171], [1173, 1173], [1175, 1175], [1177, 1177], [1179, 1179], [1181, 1181], [1183, 1183], [1185, 1185], [1187, 1187], [1189, 1189], [1191, 1191], [1193, 1193], [1195, 1195], [1197, 1197], [1199, 1199], [1201, 1201], [1203, 1203], [1205, 1205], [1207, 1207], [1209, 1209], [1211, 1211], [1213, 1213], [1215, 1215], [1218, 1218], [1220, 1220], [1222, 1222], [1224, 1224], [1226, 1226], [1228, 1228], [1230, 1231], [1233, 1233], [1235, 1235], [1237, 1237], [1239, 1239], [1241, 1241], [1243, 1243], [1245, 1245], [1247, 1247], [1249, 1249], [1251, 1251], [1253, 1253], [1255, 1255], [1257, 1257], [1259, 1259], [1261, 1261], [1263, 1263], [1265, 1265], [1267, 1267], [1269, 1269], [1271, 1271], [1273, 1273], [1275, 1275], [1277, 1277], [1279, 1279], [1281, 1281], [1283, 1283], [1285, 1285], [1287, 1287], [1289, 1289], [1291, 1291], [1293, 1293], [1295, 1295], [1297, 1297], [1299, 1299], [1301, 1301], [1303, 1303], [1305, 1305], [1307, 1307], [1309, 1309], [1311, 1311], [1313, 1313], [1315, 1315], [1317, 1317], [1319, 1319], [1321, 1321], [1323, 1323], [1325, 1325], [1327, 1327], [1377, 1415], [5112, 5117], [7296, 7304], [7424, 7467], [7531, 7543], [7545, 7578], [7681, 7681], [7683, 7683], [7685, 7685], [7687, 7687], [7689, 7689], [7691, 7691], [7693, 7693], [7695, 7695], [7697, 7697], [7699, 7699], [7701, 7701], [7703, 7703], [7705, 7705], [7707, 7707], [7709, 7709], [7711, 7711], [7713, 7713], [7715, 7715], [7717, 7717], [7719, 7719], [7721, 7721], [7723, 7723], [7725, 7725], [7727, 7727], [7729, 7729], [7731, 7731], [7733, 7733], [7735, 7735], [7737, 7737], [7739, 7739], [7741, 7741], [7743, 7743], [7745, 7745], [7747, 7747], [7749, 7749], [7751, 7751], [7753, 7753], [7755, 7755], [7757, 7757], [7759, 7759], [7761, 7761], [7763, 7763], [7765, 7765], [7767, 7767], [7769, 7769], [7771, 7771], [7773, 7773], [7775, 7775], [7777, 7777], [7779, 7779], [7781, 7781], [7783, 7783], [7785, 7785], [7787, 7787], [7789, 7789], [7791, 7791], [7793, 7793], [7795, 7795], [7797, 7797], [7799, 7799], [7801, 7801], [7803, 7803], [7805, 7805], [7807, 7807], [7809, 7809], [7811, 7811], [7813, 7813], [7815, 7815], [7817, 7817], [7819, 7819], [7821, 7821], [7823, 7823], [7825, 7825], [7827, 7827], [7829, 7837], [7839, 7839], [7841, 7841], [7843, 7843], [7845, 7845], [7847, 7847], [7849, 7849], [7851, 7851], [7853, 7853], [7855, 7855], [7857, 7857], [7859, 7859], [7861, 7861], [7863, 7863], [7865, 7865], [7867, 7867], [7869, 7869], [7871, 7871], [7873, 7873], [7875, 7875], [7877, 7877], [7879, 7879], [7881, 7881], [7883, 7883], [7885, 7885], [7887, 7887], [7889, 7889], [7891, 7891], [7893, 7893], [7895, 7895], [7897, 7897], [7899, 7899], [7901, 7901], [7903, 7903], [7905, 7905], [7907, 7907], [7909, 7909], [7911, 7911], [7913, 7913], [7915, 7915], [7917, 7917], [7919, 7919], [7921, 7921], [7923, 7923], [7925, 7925], [7927, 7927], [7929, 7929], [7931, 7931], [7933, 7933], [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8000, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], [8126, 8126], [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], [8458, 8458], [8462, 8463], [8467, 8467], [8495, 8495], [8500, 8500], [8505, 8505], [8508, 8509], [8518, 8521], [8526, 8526], [8580, 8580], [11312, 11358], [11361, 11361], [11365, 11366], [11368, 11368], [11370, 11370], [11372, 11372], [11377, 11377], [11379, 11380], [11382, 11387], [11393, 11393], [11395, 11395], [11397, 11397], [11399, 11399], [11401, 11401], [11403, 11403], [11405, 11405], [11407, 11407], [11409, 11409], [11411, 11411], [11413, 11413], [11415, 11415], [11417, 11417], [11419, 11419], [11421, 11421], [11423, 11423], [11425, 11425], [11427, 11427], [11429, 11429], [11431, 11431], [11433, 11433], [11435, 11435], [11437, 11437], [11439, 11439], [11441, 11441], [11443, 11443], [11445, 11445], [11447, 11447], [11449, 11449], [11451, 11451], [11453, 11453], [11455, 11455], [11457, 11457], [11459, 11459], [11461, 11461], [11463, 11463], [11465, 11465], [11467, 11467], [11469, 11469], [11471, 11471], [11473, 11473], [11475, 11475], [11477, 11477], [11479, 11479], [11481, 11481], [11483, 11483], [11485, 11485], [11487, 11487], [11489, 11489], [11491, 11492], [11500, 11500], [11502, 11502], [11507, 11507], [11520, 11557], [11559, 11559], [11565, 11565], [42561, 42561], [42563, 42563], [42565, 42565], [42567, 42567], [42569, 42569], [42571, 42571], [42573, 42573], [42575, 42575], [42577, 42577], [42579, 42579], [42581, 42581], [42583, 42583], [42585, 42585], [42587, 42587], [42589, 42589], [42591, 42591], [42593, 42593], [42595, 42595], [42597, 42597], [42599, 42599], [42601, 42601], [42603, 42603], [42605, 42605], [42625, 42625], [42627, 42627], [42629, 42629], [42631, 42631], [42633, 42633], [42635, 42635], [42637, 42637], [42639, 42639], [42641, 42641], [42643, 42643], [42645, 42645], [42647, 42647], [42649, 42649], [42651, 42651], [42787, 42787], [42789, 42789], [42791, 42791], [42793, 42793], [42795, 42795], [42797, 42797], [42799, 42801], [42803, 42803], [42805, 42805], [42807, 42807], [42809, 42809], [42811, 42811], [42813, 42813], [42815, 42815], [42817, 42817], [42819, 42819], [42821, 42821], [42823, 42823], [42825, 42825], [42827, 42827], [42829, 42829], [42831, 42831], [42833, 42833], [42835, 42835], [42837, 42837], [42839, 42839], [42841, 42841], [42843, 42843], [42845, 42845], [42847, 42847], [42849, 42849], [42851, 42851], [42853, 42853], [42855, 42855], [42857, 42857], [42859, 42859], [42861, 42861], [42863, 42863], [42865, 42872], [42874, 42874], [42876, 42876], [42879, 42879], [42881, 42881], [42883, 42883], [42885, 42885], [42887, 42887], [42892, 42892], [42894, 42894], [42897, 42897], [42899, 42901], [42903, 42903], [42905, 42905], [42907, 42907], [42909, 42909], [42911, 42911], [42913, 42913], [42915, 42915], [42917, 42917], [42919, 42919], [42921, 42921], [42933, 42933], [42935, 42935], [43002, 43002], [43824, 43866], [43872, 43877], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370]], \"No\": [[178, 179], [185, 185], [188, 190], [2548, 2553], [2930, 2935], [3056, 3058], [3192, 3198], [3416, 3422], [3440, 3448], [3882, 3891], [4969, 4988], [6128, 6137], [6618, 6618], [8304, 8304], [8308, 8313], [8320, 8329], [8528, 8543], [8585, 8585], [9312, 9371], [9450, 9471], [10102, 10131], [11517, 11517], [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [43056, 43061]], \"Zs\": [[32, 32], [160, 160], [5760, 5760], [8192, 8202], [8239, 8239], [8287, 8287], [12288, 12288]] }); };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/unicode-regex/lib/data.generated.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nexports.__esModule = true;\nfunction normalize_ranges(ranges) {\n    return ranges\n        .sort(function (_a, _b) {\n        var start1 = _a[0];\n        var start2 = _b[0];\n        return start1 - start2;\n    })\n        .reduce(function (current, tuple, index) {\n        if (index === 0) {\n            return [tuple];\n        }\n        var _a = current[current.length - 1], last_start = _a[0], last_end = _a[1];\n        var start = tuple[0], end = tuple[1];\n        return last_end + 1 === start\n            ? current.slice(0, -1).concat([[last_start, end]]) : current.concat([tuple]);\n    }, []);\n}\nexports.normalize_ranges = normalize_ranges;\nfunction build_regex(ranges, flag) {\n    var pattern = ranges\n        .map(function (_a) {\n        var start = _a[0], end = _a[1];\n        return start === end\n            ? \"\\\\u\" + get_hex(start)\n            : \"\\\\u\" + get_hex(start) + \"-\\\\u\" + get_hex(end);\n    })\n        .join('');\n    return new RegExp(\"[\" + pattern + \"]\", flag);\n}\nexports.build_regex = build_regex;\nfunction get_hex(char_code) {\n    var hex = char_code.toString(16);\n    while (hex.length < 4) {\n        hex = \"0\" + hex;\n    }\n    return hex;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/unicode-regex/lib/utils.js\n// module id = 18\n// module chunks = 0","\"use strict\";\n\n/*\n * utility functions for poking around the AST\n */\n\nconst { type, ESCAPE } = require(\"./utils.js\");\nconst latexAst = require(\"./latex-ast.js\");\nconst {\n    ASTNodeList,\n    ASTNode,\n    ContentOnlyNode,\n    ArgsNode,\n    Environment,\n    Macro,\n    Parbreak,\n    Whitespace,\n    Subscript,\n    Superscript,\n    InlineMath,\n    DisplayMath,\n    MathEnv,\n    Group,\n    Verbatim,\n    Verb,\n    CommentEnv,\n    CommentNode,\n    StringNode,\n    ArgList\n} = latexAst.nodeTypes;\n\nfunction strToAST(tok) {\n    // inputs a string or macro (string starting with \\\n    // and returns an AST node.\n    if (type(tok) === \"string\") {\n        if (tok.charAt(0) === \"\\\\\") {\n            tok = new Macro(tok.slice(1));\n        } else {\n            tok = new StringNode(tok);\n        }\n    }\n    return tok;\n}\n\nfunction isMathEnvironment(x) {\n    if (typeof x === \"undefined\") {\n        return false;\n    }\n    if (\n        x.TYPE === \"inlinemath\" ||\n        x.TYPE === \"displaymath\" ||\n        x.TYPE === \"mathenv\"\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction isSpaceOrPar(x) {\n    if (x == null) {\n        return false;\n    }\n    return x.TYPE === \"whitespace\" || x.TYPE === \"parbreak\";\n}\n\nfunction trimWhitespace(nodeList) {\n    // trim whitespace or newlines from the front\n    // and end of an ASTNodeList or an array\n    // this operation is destructive\n    while (nodeList.length > 0 && isSpaceOrPar(nodeList[0])) {\n        nodeList.shift();\n    }\n    while (nodeList.length > 0 && isSpaceOrPar(nodeList[nodeList.length - 1])) {\n        nodeList.pop();\n    }\n    return nodeList;\n}\n\nfunction ASTremoveExcessSpace(ast) {\n    if (!ast) {\n        return;\n    }\n    if (ast.TYPE === \"nodelist\") {\n        let ret = [],\n            lastPushed = \"\";\n\n        for (let i = 0; i < ast.length; i++) {\n            let node = ast[i];\n            ASTremoveExcessSpace(node);\n            let next = ast[i + 1] || \"\";\n            let prev = ast[i - 1] || \"\";\n\n            // we don't need spaces at the start or end of an environment\n            var isEnvironmentBody =\n                node.parent &&\n                (node.parent.parent\n                    ? node.parent.parent instanceof Environment\n                    : false);\n            if (\n                isSpaceOrPar(node) &&\n                isEnvironmentBody &&\n                (prev === \"\" || next == \"\")\n            ) {\n                continue;\n            }\n            // we don't need a space before or after an Environment\n            if (\n                isSpaceOrPar(node) &&\n                (next instanceof Environment || prev instanceof Environment)\n            ) {\n                continue;\n            }\n\n            // we're only removing whitespace and linebreaks\n            if (!isSpaceOrPar(node) || !isSpaceOrPar(lastPushed)) {\n                ret.push(node);\n                lastPushed = node;\n                continue;\n            }\n\n            if (lastPushed.TYPE === \"whitespace\" && node.TYPE === \"parbreak\") {\n                // a sequences of whitespaces and newlines should turn into a newline\n                // a sequence of whitespaces should turn into a whitespace\n                // so in this case, override the whitespace with a newline.\n                ret[ret.length - 1] = node;\n                lastPushed = node;\n            }\n        }\n\n        // glue it together in place\n        ast.length = 0;\n        for (let i of ret) {\n            ast.push(i);\n        }\n    } else if (ast.content) {\n        ASTremoveExcessSpace(ast.content);\n    }\n    return ast;\n}\n\nfunction cmpStringNode(node, cmp, substr = null) {\n    // Compares `node` with `cmp` if it is a string\n    // or a macro; if `substr='start'` returns true\n    // if the string starts with that, if `substr='end'`\n    // returns true if it ends with it.\n    // If you're comparing with a macro, `cmp` must start with \\\n    if (typeof node === \"undefined\") {\n        return false;\n    }\n    switch (node.TYPE) {\n        case \"macro\":\n            if (cmp.startsWith(\"\\\\\")) {\n                cmp = cmp.slice(1);\n            } else {\n                return false;\n            }\n        case \"string\":\n            switch (substr) {\n                case \"start\":\n                case \"starts\":\n                    return node.content.startsWith(cmp);\n                case \"end\":\n                case \"ends\":\n                    return node.content.endsWith(cmp);\n                default:\n                    return node.content === cmp ? true : false;\n            }\n    }\n    return false;\n}\n\nfunction gobbleArgsAtMacro(stream, pos = 0) {\n    // look for macro arguments [..] occuring after position `pos`.\n    // gobble them and put them in the args of the macro.\n    // This operation is destructive\n\n    var origPos = pos;\n    var openPos = null,\n        closePos = null;\n    pos++;\n    // eat the whitespace\n    while ((stream[pos] || \"\").TYPE === \"whitespace\") {\n        pos++;\n    }\n    if (!cmpStringNode(stream[pos], \"[\", \"start\")) {\n        // we gobbled all the whitespace but didn't find an opening brace\n        return stream;\n    }\n    openPos = pos;\n    while (\n        typeof stream[pos] !== \"undefined\" &&\n        !cmpStringNode(stream[pos], \"]\", \"end\")\n    ) {\n        pos++;\n    }\n    if (!cmpStringNode(stream[pos], \"]\", \"end\")) {\n        // we gobbled everything after an opening brace, but didn't find a closing one\n        return stream;\n    }\n    closePos = pos;\n\n    var removed = stream.splice(openPos, closePos - openPos + 1);\n\n    // remove the opening brace\n    if (removed[0].content === \"[\") {\n        removed.shift();\n    } else {\n        removed[0].content = removed[0].content.slice(1);\n    }\n    // remove the closing brace\n    if (removed[removed.length - 1].content === \"]\") {\n        removed.pop();\n    } else {\n        var cont = removed[removed.length - 1].content;\n        removed[removed.length - 1].content = cont.slice(0, cont.length - 1);\n    }\n    stream[origPos].args = removed;\n\n    // if we gobbled any spaces, remove them\n    if (openPos > origPos + 1) {\n        var excess = openPos - origPos - 1;\n        stream.splice(origPos + 1, excess);\n    }\n\n    return stream;\n}\n\nfunction ASTattachArgs(ast, context = {}) {\n    // find macros that have optional args attached\n    // to them and attach them.\n\n    if (!ast) {\n        return;\n    }\n\n    if (ast.TYPE === \"nodelist\") {\n        for (let i = ast.length - 1; i >= 0; i--) {\n            ASTattachArgs(ast[i], context);\n\n            // attach optional arguments to \\\\ macro\n            if (cmpStringNode(ast[i], \"\\\\\\\\\")) {\n                gobbleArgsAtMacro(ast, i);\n            }\n\n            // attach optional arguments to \\\\ macro\n            if (cmpStringNode(ast[i], \"\\\\item\")) {\n                gobbleArgsAtMacro(ast, i);\n            }\n\n            // replace \\cr in math environments\n            if (context.math && cmpStringNode(ast[i], \"\\\\cr\")) {\n                ast[i] = new Macro(\"\\\\\");\n            }\n        }\n    } else if (ast.content) {\n        if (\n            ast.TYPE === \"environment\" ||\n            ast.TYPE === \"inlinemath\" ||\n            ast.TYPE === \"displaymath\" ||\n            ast.TYPE === \"mathenv\"\n        ) {\n            context = {\n                immediate: ast,\n                math: isMathEnvironment(ast) || context.math\n            };\n        }\n        ASTattachArgs(ast.content, context);\n    }\n    return ast;\n}\n\nfunction inArray(node, arr=[]) {\n    // returns true if `node` is in array `arr`\n    if (type(arr) !== \"array\") {\n        arr = [arr]\n    }\n\n    for (let e of arr) {\n        if (cmpStringNode(node, e)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction splitTabular(ast, colSep=[\"&\"], rowSep=[\"\\\\\\\\\", \"\\\\hline\"]) {\n    // takes a node-list and returns each row\n    // in an intermediate tabular format\n    var rows = [], row = [], currCol = 0, cell = new ASTNodeList();\n\n    for (let tok of ast) {\n        if (inArray(tok, colSep)) {\n            // we're in a new column\n            row.push({content: trimWhitespace(cell), TYPE: \"cell\"})\n            row.push({content: tok, TYPE: \"colsep\"})\n            currCol++\n            cell = new ASTNodeList()\n        } else if (inArray(tok, rowSep)) {\n            // we're in a new row\n            row.push({content: trimWhitespace(cell), TYPE: \"cell\"})\n            row.push({content: tok, TYPE:\"rowsep\"})\n            rows.push(row)\n            row = []\n            currCol = 0\n            cell = new ASTNodeList()\n        } else {\n            // we're just adding to the current cell\n            cell.push(tok)\n        }\n    }\n    row.push({content: trimWhitespace(cell), TYPE:\"cell\"})\n    rows.push(row)\n\n    // now each row is an array of the form [cell, sep, cell, sep, cell, break]\n    // that is, ever other entry *must* be a cell (even if it's empty).\n    var longestRow = Math.max(...rows.map(x=>x.length))\n    var widths = []\n    widths.length = longestRow\n    widths.fill(0)\n\n    // turn each cell into a string\n    rows.forEach(x => x.forEach(y => y.content = \"\"+y.content))\n\n    for (row of rows) {\n        currCol = 0;\n        for (cell of row) {\n            if (currCol % 2 === 1) {\n                currCol++\n                continue\n            }\n            widths[currCol] = Math.max(widths[currCol], cell.content.length)\n            currCol++\n        }\n    }\n\n    return [rows, widths]\n\n}\n\nwindow.ft = splitTabular\nmodule.exports = {\n    ASTattachArgs,\n    gobbleArgsAtMacro,\n    cmpStringNode,\n    ASTremoveExcessSpace,\n    trimWhitespace,\n    isSpaceOrPar,\n    isMathEnvironment,\n    strToAST,\n    splitTabular\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ast-utils.js\n// module id = 19\n// module chunks = 0","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { document: peg$parsedocument },\n      peg$startRuleFunction  = peg$parsedocument,\n\n      peg$c0 = peg$otherExpectation(\"document\"),\n      peg$c1 = peg$otherExpectation(\"token\"),\n      peg$c2 = function(t) {return t},\n      peg$c3 = function(eq) {return {TYPE:\"inlinemath\", content: eq}},\n      peg$c4 = function() {return {TYPE:\"parbreak\"}},\n      peg$c5 = peg$anyExpectation(),\n      peg$c6 = function(x) {return x},\n      peg$c7 = function(x) {return x.join(\"\")},\n      peg$c8 = peg$otherExpectation(\"math token\"),\n      peg$c9 = function(x) {return {TYPE:\"superscript\", content:x}},\n      peg$c10 = function(x) {return {TYPE:\"subscript\", content:x}},\n      peg$c11 = peg$otherExpectation(\"args token\"),\n      peg$c12 = \",\",\n      peg$c13 = peg$literalExpectation(\",\", false),\n      peg$c14 = \"]\",\n      peg$c15 = peg$literalExpectation(\"]\", false),\n      peg$c16 = peg$otherExpectation(\"nonchar token\"),\n      peg$c17 = \"%\",\n      peg$c18 = peg$literalExpectation(\"%\", false),\n      peg$c19 = peg$otherExpectation(\"whitespace\"),\n      peg$c20 = function() {return {TYPE: \"whitespace\"}},\n      peg$c21 = peg$otherExpectation(\"number\"),\n      peg$c22 = \".\",\n      peg$c23 = peg$literalExpectation(\".\", false),\n      peg$c24 = function(a, b) {return a.join(\"\") + \".\" + b.join(\"\")},\n      peg$c25 = function(b) {return \".\" + b.join(\"\")},\n      peg$c26 = function(a) {return a.join(\"\") + \".\"},\n      peg$c27 = peg$otherExpectation(\"special macro\"),\n      peg$c28 = \"verb\",\n      peg$c29 = peg$literalExpectation(\"verb\", false),\n      peg$c30 = function(e, end) {return end == e},\n      peg$c31 = function(e, x) {return x},\n      peg$c32 = function(e, x, end) {return end == e},\n      peg$c33 = function(e, x) {return {TYPE:\"verb\", escape:e, content:x.join(\"\")}},\n      peg$c34 = \"begin{verbatim}\",\n      peg$c35 = peg$literalExpectation(\"begin{verbatim}\", false),\n      peg$c36 = \"end{verbatim}\",\n      peg$c37 = peg$literalExpectation(\"end{verbatim}\", false),\n      peg$c38 = function(x) {return {TYPE:\"verbatim\", content:x.join(\"\")}},\n      peg$c39 = \"begin{comment}\",\n      peg$c40 = peg$literalExpectation(\"begin{comment}\", false),\n      peg$c41 = \"end{comment}\",\n      peg$c42 = peg$literalExpectation(\"end{comment}\", false),\n      peg$c43 = function(x) {return {TYPE:\"commentenv\", content:x.join(\"\")}},\n      peg$c44 = function(x) {return {TYPE:\"displaymath\", content:x}},\n      peg$c45 = function(x) {return {TYPE:\"inlinemath\", content:x}},\n      peg$c46 = peg$otherExpectation(\"macro\"),\n      peg$c47 = function(n) {return n.join(\"\")},\n      peg$c48 = function(n) {return n},\n      peg$c49 = function(m) {return {TYPE:\"macro\", content:m}},\n      peg$c50 = peg$otherExpectation(\"group\"),\n      peg$c51 = function(c) {return c},\n      peg$c52 = function(x) {return {TYPE:\"group\", content:x}},\n      peg$c53 = peg$otherExpectation(\"argument list\"),\n      peg$c54 = \"[\",\n      peg$c55 = peg$literalExpectation(\"[\", false),\n      peg$c56 = function(body) {return {TYPE:\"arglist\", content:body}},\n      peg$c57 = peg$otherExpectation(\"environment\"),\n      peg$c58 = function(env, args, end_env) {return compare_env(env,end_env)},\n      peg$c59 = function(env, args, x) {return x},\n      peg$c60 = function(env, args, body) {return {TYPE:\"environment\", env:env.content, args:args, content:body}},\n      peg$c61 = peg$otherExpectation(\"math environment\"),\n      peg$c62 = function(env, end_env) {console.log(env, end_env,  compare_env({content:[env]},end_env));return compare_env({content:[env]},end_env)},\n      peg$c63 = function(env, x) {return x},\n      peg$c64 = function(env, body) {return {TYPE:\"mathenv\", env:env, content:body}},\n      peg$c65 = peg$otherExpectation(\"math group\"),\n      peg$c66 = peg$otherExpectation(\"full comment\"),\n      peg$c67 = function(x) {return {TYPE:\"comment\", content:x, sameline:false}},\n      peg$c68 = function(x) {return {TYPE:\"comment\", content:x, sameline:true}},\n      peg$c69 = \"(\",\n      peg$c70 = peg$literalExpectation(\"(\", false),\n      peg$c71 = \")\",\n      peg$c72 = peg$literalExpectation(\")\", false),\n      peg$c73 = \"begin\",\n      peg$c74 = peg$literalExpectation(\"begin\", false),\n      peg$c75 = \"end\",\n      peg$c76 = peg$literalExpectation(\"end\", false),\n      peg$c77 = \"equation*\",\n      peg$c78 = peg$literalExpectation(\"equation*\", false),\n      peg$c79 = \"equation\",\n      peg$c80 = peg$literalExpectation(\"equation\", false),\n      peg$c81 = \"align*\",\n      peg$c82 = peg$literalExpectation(\"align*\", false),\n      peg$c83 = \"align\",\n      peg$c84 = peg$literalExpectation(\"align\", false),\n      peg$c85 = \"alignat*\",\n      peg$c86 = peg$literalExpectation(\"alignat*\", false),\n      peg$c87 = \"alignat\",\n      peg$c88 = peg$literalExpectation(\"alignat\", false),\n      peg$c89 = \"gather*\",\n      peg$c90 = peg$literalExpectation(\"gather*\", false),\n      peg$c91 = \"gather\",\n      peg$c92 = peg$literalExpectation(\"gather\", false),\n      peg$c93 = \"multline*\",\n      peg$c94 = peg$literalExpectation(\"multline*\", false),\n      peg$c95 = \"multline\",\n      peg$c96 = peg$literalExpectation(\"multline\", false),\n      peg$c97 = \"flalign*\",\n      peg$c98 = peg$literalExpectation(\"flalign*\", false),\n      peg$c99 = \"flalign\",\n      peg$c100 = peg$literalExpectation(\"flalign\", false),\n      peg$c101 = \"split\",\n      peg$c102 = peg$literalExpectation(\"split\", false),\n      peg$c103 = \"math\",\n      peg$c104 = peg$literalExpectation(\"math\", false),\n      peg$c105 = \"displaymath\",\n      peg$c106 = peg$literalExpectation(\"displaymath\", false),\n      peg$c107 = peg$otherExpectation(\"escape\"),\n      peg$c108 = \"\\\\\",\n      peg$c109 = peg$literalExpectation(\"\\\\\", false),\n      peg$c110 = \"{\",\n      peg$c111 = peg$literalExpectation(\"{\", false),\n      peg$c112 = \"}\",\n      peg$c113 = peg$literalExpectation(\"}\", false),\n      peg$c114 = \"$\",\n      peg$c115 = peg$literalExpectation(\"$\", false),\n      peg$c116 = \"&\",\n      peg$c117 = peg$literalExpectation(\"&\", false),\n      peg$c118 = peg$otherExpectation(\"newline\"),\n      peg$c119 = \"\\r\",\n      peg$c120 = peg$literalExpectation(\"\\r\", false),\n      peg$c121 = \"\\n\",\n      peg$c122 = peg$literalExpectation(\"\\n\", false),\n      peg$c123 = \"\\r\\n\",\n      peg$c124 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c125 = \"#\",\n      peg$c126 = peg$literalExpectation(\"#\", false),\n      peg$c127 = \"^\",\n      peg$c128 = peg$literalExpectation(\"^\", false),\n      peg$c129 = \"_\",\n      peg$c130 = peg$literalExpectation(\"_\", false),\n      peg$c131 = \"\\0\",\n      peg$c132 = peg$literalExpectation(\"\\0\", false),\n      peg$c133 = /^[ \\t]/,\n      peg$c134 = peg$classExpectation([\" \", \"\\t\"], false, false),\n      peg$c135 = function() { return \" \"},\n      peg$c136 = peg$otherExpectation(\"letter\"),\n      peg$c137 = /^[a-zA-Z]/,\n      peg$c138 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c139 = peg$otherExpectation(\"digit\"),\n      peg$c140 = /^[0-9]/,\n      peg$c141 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c142 = peg$otherExpectation(\"punctuation\"),\n      peg$c143 = /^[.,;:\\-*\\/()!?=+<>[\\]]/,\n      peg$c144 = peg$classExpectation([\".\", \",\", \";\", \":\", \"-\", \"*\", \"/\", \"(\", \")\", \"!\", \"?\", \"=\", \"+\", \"<\", \">\", \"[\", \"]\"], false, false),\n      peg$c145 = function(c) {return c.join(\"\")},\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsedocument() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parsetoken();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parsetoken();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$parsespecial_macro();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemacro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefull_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsegroup();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsemath_shift();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parsemath_shift();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c2(s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parsemath_shift();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = void 0;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s4 = peg$c2(s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              } else {\n                s2 = peg$FAILED;\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsemath_shift();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c3(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsealignment_tab();\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsesp();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsesp();\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsenl();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parsenl();\n                    if (s4 !== peg$FAILED) {\n                      while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parsenl();\n                      }\n                    } else {\n                      s3 = peg$FAILED;\n                    }\n                    if (s3 !== peg$FAILED) {\n                      s4 = [];\n                      s5 = peg$parsesp();\n                      while (s5 !== peg$FAILED) {\n                        s4.push(s5);\n                        s5 = peg$parsesp();\n                      }\n                      if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c4();\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsesuperscript();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsesubscript();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenumber();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsewhitespace();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$currPos;\n                              s1 = [];\n                              s2 = peg$currPos;\n                              s3 = peg$currPos;\n                              peg$silentFails++;\n                              s4 = peg$parsenonchar_token();\n                              peg$silentFails--;\n                              if (s4 === peg$FAILED) {\n                                s3 = void 0;\n                              } else {\n                                peg$currPos = s3;\n                                s3 = peg$FAILED;\n                              }\n                              if (s3 !== peg$FAILED) {\n                                if (input.length > peg$currPos) {\n                                  s4 = input.charAt(peg$currPos);\n                                  peg$currPos++;\n                                } else {\n                                  s4 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                                }\n                                if (s4 !== peg$FAILED) {\n                                  peg$savedPos = s2;\n                                  s3 = peg$c6(s4);\n                                  s2 = s3;\n                                } else {\n                                  peg$currPos = s2;\n                                  s2 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s2;\n                                s2 = peg$FAILED;\n                              }\n                              if (s2 !== peg$FAILED) {\n                                while (s2 !== peg$FAILED) {\n                                  s1.push(s2);\n                                  s2 = peg$currPos;\n                                  s3 = peg$currPos;\n                                  peg$silentFails++;\n                                  s4 = peg$parsenonchar_token();\n                                  peg$silentFails--;\n                                  if (s4 === peg$FAILED) {\n                                    s3 = void 0;\n                                  } else {\n                                    peg$currPos = s3;\n                                    s3 = peg$FAILED;\n                                  }\n                                  if (s3 !== peg$FAILED) {\n                                    if (input.length > peg$currPos) {\n                                      s4 = input.charAt(peg$currPos);\n                                      peg$currPos++;\n                                    } else {\n                                      s4 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                                    }\n                                    if (s4 !== peg$FAILED) {\n                                      peg$savedPos = s2;\n                                      s3 = peg$c6(s4);\n                                      s2 = s3;\n                                    } else {\n                                      peg$currPos = s2;\n                                      s2 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s2;\n                                    s2 = peg$FAILED;\n                                  }\n                                }\n                              } else {\n                                s1 = peg$FAILED;\n                              }\n                              if (s1 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c7(s1);\n                              }\n                              s0 = s1;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_token() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$parsespecial_macro();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemacro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsefull_comment();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c6(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewhitespace();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewhitespace();\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsegroup();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewhitespace();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewhitespace();\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c6(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = [];\n            s2 = peg$parsewhitespace();\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsewhitespace();\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsealignment_tab();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parsewhitespace();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parsewhitespace();\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c6(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = [];\n              s2 = peg$parsewhitespace();\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$parsewhitespace();\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parsemacro_parameter();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$parsewhitespace();\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$parsewhitespace();\n                  }\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c6(s2);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsewhitespace();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsewhitespace();\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsesuperscript();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parsewhitespace();\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$parsewhitespace();\n                    }\n                    if (s3 !== peg$FAILED) {\n                      s4 = peg$parsemath_token();\n                      if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c9(s4);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = [];\n                  s2 = peg$parsewhitespace();\n                  while (s2 !== peg$FAILED) {\n                    s1.push(s2);\n                    s2 = peg$parsewhitespace();\n                  }\n                  if (s1 !== peg$FAILED) {\n                    s2 = peg$parsesubscript();\n                    if (s2 !== peg$FAILED) {\n                      s3 = [];\n                      s4 = peg$parsewhitespace();\n                      while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parsewhitespace();\n                      }\n                      if (s3 !== peg$FAILED) {\n                        s4 = peg$parsemath_token();\n                        if (s4 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c10(s4);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseignore();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsewhitespace();\n                      if (s0 === peg$FAILED) {\n                        if (input.length > peg$currPos) {\n                          s0 = input.charAt(peg$currPos);\n                          peg$currPos++;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseargs_token() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$parsespecial_macro();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemacro();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefull_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsegroup();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsemath_shift();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parsemath_shift();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c2(s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parsemath_shift();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = void 0;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s4 = peg$c2(s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              } else {\n                s2 = peg$FAILED;\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsemath_shift();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c3(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsealignment_tab();\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsesp();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsesp();\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsenl();\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parsenl();\n                    if (s4 !== peg$FAILED) {\n                      while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parsenl();\n                      }\n                    } else {\n                      s3 = peg$FAILED;\n                    }\n                    if (s3 !== peg$FAILED) {\n                      s4 = [];\n                      s5 = peg$parsesp();\n                      while (s5 !== peg$FAILED) {\n                        s4.push(s5);\n                        s5 = peg$parsesp();\n                      }\n                      if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c4();\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsesuperscript();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsesubscript();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenumber();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsewhitespace();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$currPos;\n                              s1 = [];\n                              s2 = peg$currPos;\n                              s3 = peg$currPos;\n                              peg$silentFails++;\n                              s4 = peg$parsenonchar_token();\n                              if (s4 === peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 44) {\n                                  s4 = peg$c12;\n                                  peg$currPos++;\n                                } else {\n                                  s4 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                                }\n                                if (s4 === peg$FAILED) {\n                                  if (input.charCodeAt(peg$currPos) === 93) {\n                                    s4 = peg$c14;\n                                    peg$currPos++;\n                                  } else {\n                                    s4 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c15); }\n                                  }\n                                }\n                              }\n                              peg$silentFails--;\n                              if (s4 === peg$FAILED) {\n                                s3 = void 0;\n                              } else {\n                                peg$currPos = s3;\n                                s3 = peg$FAILED;\n                              }\n                              if (s3 !== peg$FAILED) {\n                                if (input.length > peg$currPos) {\n                                  s4 = input.charAt(peg$currPos);\n                                  peg$currPos++;\n                                } else {\n                                  s4 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                                }\n                                if (s4 !== peg$FAILED) {\n                                  peg$savedPos = s2;\n                                  s3 = peg$c6(s4);\n                                  s2 = s3;\n                                } else {\n                                  peg$currPos = s2;\n                                  s2 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s2;\n                                s2 = peg$FAILED;\n                              }\n                              if (s2 !== peg$FAILED) {\n                                while (s2 !== peg$FAILED) {\n                                  s1.push(s2);\n                                  s2 = peg$currPos;\n                                  s3 = peg$currPos;\n                                  peg$silentFails++;\n                                  s4 = peg$parsenonchar_token();\n                                  if (s4 === peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 44) {\n                                      s4 = peg$c12;\n                                      peg$currPos++;\n                                    } else {\n                                      s4 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                                    }\n                                    if (s4 === peg$FAILED) {\n                                      if (input.charCodeAt(peg$currPos) === 93) {\n                                        s4 = peg$c14;\n                                        peg$currPos++;\n                                      } else {\n                                        s4 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n                                      }\n                                    }\n                                  }\n                                  peg$silentFails--;\n                                  if (s4 === peg$FAILED) {\n                                    s3 = void 0;\n                                  } else {\n                                    peg$currPos = s3;\n                                    s3 = peg$FAILED;\n                                  }\n                                  if (s3 !== peg$FAILED) {\n                                    if (input.length > peg$currPos) {\n                                      s4 = input.charAt(peg$currPos);\n                                      peg$currPos++;\n                                    } else {\n                                      s4 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                                    }\n                                    if (s4 !== peg$FAILED) {\n                                      peg$savedPos = s2;\n                                      s3 = peg$c6(s4);\n                                      s2 = s3;\n                                    } else {\n                                      peg$currPos = s2;\n                                      s2 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s2;\n                                    s2 = peg$FAILED;\n                                  }\n                                }\n                              } else {\n                                s1 = peg$FAILED;\n                              }\n                              if (s1 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c7(s1);\n                              }\n                              s0 = s1;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c11); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonchar_token() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseescape();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 37) {\n        s0 = peg$c17;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebegin_group();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseend_group();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsemath_shift();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsealignment_tab();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsenl();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsesuperscript();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsesubscript();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsesp();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseEOF();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c16); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsenl();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsesp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsesp();\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsesp();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsesp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenl();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsesp();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsesp();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsenl();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = [];\n        s2 = peg$parsesp();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsesp();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c20();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsenum();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsenum();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s2 = peg$c22;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsenum();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsenum();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsenum();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenum();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsenum();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsenum();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s2 = peg$c22;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c23); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c26(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsespecial_macro() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 4) === peg$c28) {\n        s2 = peg$c28;\n        peg$currPos += 4;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          if (input.length > peg$currPos) {\n            s8 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s9 = peg$c30(s3, s8);\n            if (s9) {\n              s9 = void 0;\n            } else {\n              s9 = peg$FAILED;\n            }\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s6 = peg$c31(s3, s7);\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s8 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s9 = peg$c30(s3, s8);\n              if (s9) {\n                s9 = void 0;\n              } else {\n                s9 = peg$FAILED;\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c5); }\n              }\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s6 = peg$c31(s3, s7);\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s7 = peg$c32(s3, s4, s6);\n              if (s7) {\n                s7 = void 0;\n              } else {\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c33(s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseescape();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 15) === peg$c34) {\n          s2 = peg$c34;\n          peg$currPos += 15;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c35); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$currPos;\n          s7 = peg$parseescape();\n          if (s7 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 13) === peg$c36) {\n              s8 = peg$c36;\n              peg$currPos += 13;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s8 !== peg$FAILED) {\n              s7 = [s7, s8];\n              s6 = s7;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c6(s6);\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$currPos;\n            s7 = peg$parseescape();\n            if (s7 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 13) === peg$c36) {\n                s8 = peg$c36;\n                peg$currPos += 13;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c37); }\n              }\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c5); }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c6(s6);\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseescape();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 13) === peg$c36) {\n                s5 = peg$c36;\n                peg$currPos += 13;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c37); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c38(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 14) === peg$c39) {\n            s2 = peg$c39;\n            peg$currPos += 14;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$currPos;\n            s7 = peg$parseescape();\n            if (s7 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 12) === peg$c41) {\n                s8 = peg$c41;\n                peg$currPos += 12;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c42); }\n              }\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c5); }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c6(s6);\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$currPos;\n              s5 = peg$currPos;\n              peg$silentFails++;\n              s6 = peg$currPos;\n              s7 = peg$parseescape();\n              if (s7 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 12) === peg$c41) {\n                  s8 = peg$c41;\n                  peg$currPos += 12;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s6 === peg$FAILED) {\n                s5 = void 0;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s4;\n                  s5 = peg$c6(s6);\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseescape();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 12) === peg$c41) {\n                  s5 = peg$c41;\n                  peg$currPos += 12;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c43(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsebegin_display_math();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseend_display_math();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemath_token();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c6(s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseend_display_math();\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = void 0;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsemath_token();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s4 = peg$c6(s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseend_display_math();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c44(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsebegin_inline_math();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseend_inline_math();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsemath_token();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c6(s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parseend_inline_math();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = void 0;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s4 = peg$c6(s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              } else {\n                s2 = peg$FAILED;\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseend_inline_math();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c45(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsemath_shift();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parsemath_shift();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$currPos;\n                  s5 = peg$currPos;\n                  peg$silentFails++;\n                  s6 = peg$currPos;\n                  s7 = peg$parsemath_shift();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsemath_shift();\n                    if (s8 !== peg$FAILED) {\n                      s7 = [s7, s8];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                  peg$silentFails--;\n                  if (s6 === peg$FAILED) {\n                    s5 = void 0;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemath_token();\n                    if (s6 !== peg$FAILED) {\n                      peg$savedPos = s4;\n                      s5 = peg$c6(s6);\n                      s4 = s5;\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$currPos;\n                      s5 = peg$currPos;\n                      peg$silentFails++;\n                      s6 = peg$currPos;\n                      s7 = peg$parsemath_shift();\n                      if (s7 !== peg$FAILED) {\n                        s8 = peg$parsemath_shift();\n                        if (s8 !== peg$FAILED) {\n                          s7 = [s7, s8];\n                          s6 = s7;\n                        } else {\n                          peg$currPos = s6;\n                          s6 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                      peg$silentFails--;\n                      if (s6 === peg$FAILED) {\n                        s5 = void 0;\n                      } else {\n                        peg$currPos = s5;\n                        s5 = peg$FAILED;\n                      }\n                      if (s5 !== peg$FAILED) {\n                        s6 = peg$parsemath_token();\n                        if (s6 !== peg$FAILED) {\n                          peg$savedPos = s4;\n                          s5 = peg$c6(s6);\n                          s4 = s5;\n                        } else {\n                          peg$currPos = s4;\n                          s4 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    }\n                  } else {\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s4 = peg$parsemath_shift();\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parsemath_shift();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c44(s3);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsemath_environment();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseenvironment();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseescape();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsechar();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsechar();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c47(s3);\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parseescape();\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c48(s3);\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_group();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseend_group();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsetoken();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c51(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetoken();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c51(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseend_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c52(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseargument_list() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewhitespace();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewhitespace();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c54;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c55); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s6 = peg$c14;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = void 0;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s6 = peg$c12;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s6 === peg$FAILED) {\n            s6 = peg$parseargs_token();\n          }\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = s4;\n            s5 = peg$c6(s6);\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s6 = peg$c14;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s6 = peg$c12;\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c13); }\n            }\n            if (s6 === peg$FAILED) {\n              s6 = peg$parseargs_token();\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c6(s6);\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s4 = peg$c14;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c56(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c53); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseenvironment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsegroup();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseargument_list();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          s8 = peg$parseend_env();\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parsegroup();\n            if (s9 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s10 = peg$c58(s2, s3, s9);\n              if (s10) {\n                s10 = void 0;\n              } else {\n                s10 = peg$FAILED;\n              }\n              if (s10 !== peg$FAILED) {\n                s8 = [s8, s9, s10];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsetoken();\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s6 = peg$c59(s2, s3, s7);\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            s8 = peg$parseend_env();\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parsegroup();\n              if (s9 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s10 = peg$c58(s2, s3, s9);\n                if (s10) {\n                  s10 = void 0;\n                } else {\n                  s10 = peg$FAILED;\n                }\n                if (s10 !== peg$FAILED) {\n                  s8 = [s8, s9, s10];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsetoken();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s6 = peg$c59(s2, s3, s7);\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseend_env();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsegroup();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c60(s2, s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c57); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_environment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_env();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsebegin_group();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemath_env_name();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseend_group();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            peg$silentFails++;\n            s8 = peg$currPos;\n            s9 = peg$parseend_env();\n            if (s9 !== peg$FAILED) {\n              s10 = peg$parsegroup();\n              if (s10 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s11 = peg$c62(s3, s10);\n                if (s11) {\n                  s11 = void 0;\n                } else {\n                  s11 = peg$FAILED;\n                }\n                if (s11 !== peg$FAILED) {\n                  s9 = [s9, s10, s11];\n                  s8 = s9;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s8 === peg$FAILED) {\n              s7 = void 0;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsemath_token();\n              if (s8 !== peg$FAILED) {\n                peg$savedPos = s6;\n                s7 = peg$c63(s3, s8);\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$currPos;\n              s9 = peg$parseend_env();\n              if (s9 !== peg$FAILED) {\n                s10 = peg$parsegroup();\n                if (s10 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s11 = peg$c62(s3, s10);\n                  if (s11) {\n                    s11 = void 0;\n                  } else {\n                    s11 = peg$FAILED;\n                  }\n                  if (s11 !== peg$FAILED) {\n                    s9 = [s9, s10, s11];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsemath_token();\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = s6;\n                  s7 = peg$c63(s3, s8);\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseend_env();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebegin_group();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsemath_env_name();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseend_group();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c64(s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_group() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsebegin_group();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseend_group();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemath_token();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c51(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseend_group();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemath_token();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c51(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseend_group();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c52(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c65); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefull_comment() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsenl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomment();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c67(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomment();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c68(s1);\n      }\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_display_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c54;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c55); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_display_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s2 = peg$c14;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_inline_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c69;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_inline_math() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c71;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_env() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 5) === peg$c73) {\n        s2 = peg$c73;\n        peg$currPos += 5;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_env() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescape();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c75) {\n        s2 = peg$c75;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c76); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_env_name() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c77) {\n      s0 = peg$c77;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c78); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 8) === peg$c79) {\n        s0 = peg$c79;\n        peg$currPos += 8;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c81) {\n          s0 = peg$c81;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c83) {\n            s0 = peg$c83;\n            peg$currPos += 5;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c85) {\n              s0 = peg$c85;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c87) {\n                s0 = peg$c87;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c88); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c89) {\n                  s0 = peg$c89;\n                  peg$currPos += 7;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c90); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 6) === peg$c91) {\n                    s0 = peg$c91;\n                    peg$currPos += 6;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 9) === peg$c93) {\n                      s0 = peg$c93;\n                      peg$currPos += 9;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c94); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 8) === peg$c95) {\n                        s0 = peg$c95;\n                        peg$currPos += 8;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c96); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c97) {\n                          s0 = peg$c97;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c98); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 7) === peg$c99) {\n                            s0 = peg$c99;\n                            peg$currPos += 7;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c100); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 5) === peg$c101) {\n                              s0 = peg$c101;\n                              peg$currPos += 5;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c102); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 4) === peg$c103) {\n                                s0 = peg$c103;\n                                peg$currPos += 4;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c104); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 11) === peg$c105) {\n                                  s0 = peg$c105;\n                                  peg$currPos += 11;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c106); }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseescape() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s0 = peg$c108;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c109); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c107); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebegin_group() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s0 = peg$c110;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c111); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseend_group() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 125) {\n      s0 = peg$c112;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c113); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemath_shift() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s0 = peg$c114;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c115); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsealignment_tab() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 38) {\n      s0 = peg$c116;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c117); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenl() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 13) {\n      s2 = peg$c119;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c120); }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s2 = peg$c121;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c122); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 13) {\n        s0 = peg$c119;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c120); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c123) {\n          s0 = peg$c123;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c124); }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c118); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemacro_parameter() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s0 = peg$c125;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c126); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesuperscript() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 94) {\n      s0 = peg$c127;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c128); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubscript() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 95) {\n      s0 = peg$c129;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c130); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseignore() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 0) {\n      s0 = peg$c131;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c132); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesp() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c133.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c134); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c133.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c134); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c135();\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c137.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c138); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c136); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenum() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c140.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c141); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c139); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepunctuation() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c143.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c144); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c142); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 37) {\n      s1 = peg$c17;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parsenl();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c51(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsenl();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c51(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenl();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseEOF();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c145(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = void 0;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n      function compare_env(g1,g2) {\n          return g1.content.join(\"\") == g2.content.join(\"\");\n      }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/latexpeg.js\n// module id = 20\n// module chunks = 0","\"use strict\";\n/*\n * add token-based formatting to the AST\n */\n\nconst {type, ESCAPE, callSuper} = require(\"./utils.js\")\nconst latexAst = require(\"./latex-ast.js\")\n\nconst {\n        ASTNodeList,\n        ASTNode,\n        ContentOnlyNode,\n        ArgsNode,\n        Environment,\n        Macro,\n        Parbreak,\n        Whitespace,\n        Subscript,\n        Superscript,\n        InlineMath,\n        DisplayMath,\n        MathEnv,\n        Group,\n        Verbatim,\n        Verb,\n        CommentEnv,\n        CommentNode,\n        StringNode,\n        ArgList,\n    } = latexAst.nodeTypes;\n\n/*\n * Special tokens used in the token stream\n */\n\nconst TOKENS = {\n    indent: Symbol(\"indent\"),\n    endindent: Symbol(\"endindent\"),\n    nowrap: Symbol(\"nowrap\"),\n    endnowrap: Symbol(\"endnowrap\"),\n    newline: Symbol(\"newline\"),\n    ensurenew: Symbol(\"ensurenew\"), // ensure that there is a new line inserted, but don't insert one if there's already one\n    ensurepar: Symbol(\"ensurepar\"),\n    preferpar: Symbol(\"preferpar\"), // prefer a par, but if there is a newline there already, accept that\n    parbreak: Symbol(\"parbreak\"),\n    whitespace: Symbol(\"whitespace\")\n};\n        \n\n/*\n * Add toTokens method to each class\n */\n\nASTNodeList.prototype.toTokens = function() {\n    return [].concat.apply([], this.map(x => x.toTokens()));\n};\n\nArgsNode.prototype.toTokens = function() {\n    if (this.args) {\n        return [\"[\"].concat(this.args.toTokens()).concat(\"]\");\n    }\n    return [];\n};\n\nEnvironment.prototype.toTokens = function() {\n    return [].concat.call(\n        [],\n        [TOKENS.ensurenew, this.envStart, TOKENS.indent],\n        callSuper(this, \"toTokens\"), // ArgsNode knows how to make arguments into tokens\n        [TOKENS.newline],\n        this.content.toTokens(),\n        [TOKENS.endindent, TOKENS.newline, this.envEnd]\n    );\n};\n\nMacro.prototype.toTokens = function() {\n        let start = [ESCAPE + this.content];\n        // there are some special macros that\n        // need special formatting\n        switch (this.content) {\n            case \"usepackage\":\n            case \"newcommand\":\n                start = [TOKENS.ensurenew].concat(start);\n                break;\n            case \"item\":\n                start = [TOKENS.preferpar].concat(start);\n                break;\n        }\n        return start.concat(callSuper(this, \"toTokens\"));\n};\n\nParbreak.prototype.toTokens = function() {\n    return [TOKENS.parbreak];\n};\n\nWhitespace.prototype.toTokens = function() {\n    return [TOKENS.whitespace];\n};\n\nSubscript.prototype.toTokens = function() {\n    if (this.content.TYPE === \"group\") {\n        return [].concat.call([], [\"_\"], this.content.toTokens());\n    }\n    return [].concat.call([], [\"_{\"], this.content.toTokens(), [\"}\"]);\n};\n\nSuperscript.prototype.toTokens = function() {\n    if (this.content.TYPE === \"group\") {\n        return [].concat.call([], [\"^\"], this.content.toTokens());\n    }\n    return [].concat.call([], [\"^{\"], this.content.toTokens(), [\"}\"]);\n};\n\nInlineMath.prototype.toTokens = function() {\n    return [].concat.call([], [\"$\"], this.content.toTokens(), [\"$\"]);\n};\n\nDisplayMath.prototype.toTokens = function() {\n    return [].concat.call(\n        [],\n        [TOKENS.newline, ESCAPE + \"[\", TOKENS.indent, TOKENS.newline],\n        this.content.toTokens(),\n        [TOKENS.endindent, TOKENS.newline, ESCAPE + \"]\", TOKENS.newline]\n    );\n};\n\nGroup.prototype.toTokens = function() {\n    return [].concat.call(\n        [],\n        [TOKENS.nowrap, \"{\"],\n        this.content.toTokens(),\n        [\"}\", TOKENS.endnowrap]\n    );\n};\n\nVerbatim.prototype.toTokens = function() {\n    // Verbatim blocks are a single token\n    return [TOKENS.nowrap, \"\" + this, TOKENS.endnowrap];\n};\n\nVerb.prototype.toTokens = Verbatim.prototype.toTokens;\n\nCommentEnv.prototype.toTokens = Verbatim.prototype.toTokens;\n\nCommentNode.prototype.toTokens = function() {\n    if (this.sameline) {\n        return [\"%\", \"\" + this.content, TOKENS.newline];\n    }\n    return [TOKENS.newline, \"%\", \"\" + this.content, TOKENS.newline];\n};\n\nStringNode.prototype.toTokens = function() {\n    return [this.content]\n};\n\nArgList.prototype.toTokens = function() {\n    return this.content.toTokens()\n};\n\n\n/*\n * Print a token stream\n */\n// barebones printer for token streams\nfunction printTokenStream(stream, maxwidth=60, tabwidth=8) {\n    function wrappable(token) {\n        if (type(token) !== 'string') {\n            return false\n        }\n        token = token[0]\n        return !token.match(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/)\n    }\n    var ret = \"\";\n    var padding = \"\";\n    var currlen = 0, width = 0;\n    var nowrap = 0;\n    var prevFunctionalToken = null;\n    for (let i=0; i < stream.length; i++) {\n        var token = stream[i];\n\n        // handle all special tokens\n        switch (token) {\n            case TOKENS.indent:\n                padding += \"\\t\"\n                break\n            case TOKENS.endindent:\n                padding = padding.slice(0, padding.length - 1)\n                break\n            case TOKENS.nowrap:\n                nowrap += 1\n                break\n            case TOKENS.endnowrap:\n                nowrap = nowrap > 0 ? nowrap - 1 : 0\n                break\n            case TOKENS.ensurenew:\n                // if we just put down a newline or parbreak, ensurenew doesn't need to do anything\n                if (prevFunctionalToken == TOKENS.newline || prevFunctionalToken == TOKENS.parbreak) {\n                    break;\n                }\n            case TOKENS.newline:\n                ret += \"\\n\" + padding;\n                currlen = padding.length*tabwidth;\n                break\n            case TOKENS.ensurepar:\n                if (prevFunctionalToken == TOKENS.parbreak) {\n                    break;\n                } else if (prevFunctionalToken == TOKENS.newline) {\n                    // if we just put down a newline, then only add one more newline\n                    ret += \"\\n\" + padding;\n                    currlen = padding.length*tabwidth;\n                    break;\n                }\n            case TOKENS.preferpar:\n                // if there is no break, make a par break, but if there was just a break, that's\n                // good enough.\n                if (prevFunctionalToken == TOKENS.newline || prevFunctionalToken == TOKENS.parbreak) {\n                    break;\n                }\n            case TOKENS.parbreak:\n                ret += \"\\n\\n\" + padding;\n                currlen = padding.length*tabwidth;\n                break\n            case TOKENS.whitespace:\n                ret += \" \"\n        }\n        if (type(token) === 'string') {\n                // if it won't fit on this line but will fit on the next line\n                // and it's a wrappable character (e.g., not punctuation)\n                if (currlen + token.length > maxwidth \n                    && padding.length*tabwidth + token.length < maxwidth\n                    && !nowrap\n                    && wrappable(token)) {\n                    ret += \"\\n\" + padding;\n                    currlen = padding.length*tabwidth;\n                }\n                ret += token;\n                currlen += token.length;\n\n        }\n        if (token != TOKENS.indent && token != TOKENS.endindent && token != TOKENS.nowrap && token != TOKENS.endnowrap) {\n            prevFunctionalToken = token;\n        }\n    }\n    return ret;\n}\n\n\nmodule.exports = {\n    tokens: TOKENS,\n    printTokenStream\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatter-token.js\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}